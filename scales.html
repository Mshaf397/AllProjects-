<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Microtonal Circle-of-"Fifths" Generator</title>
  <style>
    body { font-family: sans-serif; padding: 1em; max-width: 700px; }
    input, button { padding: 0.5em; margin: 0.5em 0.2em; font-size: 1em; }
    table { border-collapse: collapse; margin-top: 1em; width: 100%; }
    th, td { border: 1px solid #aaa; padding: 0.4em; text-align: right; }
    th { background-color: #f0f0f0; }
  </style>
</head>
<body>
  <h1>Microtonal Circle-of-"Fifths" Generator</h1>

  <label>Generator: <input id="generator" value="3/2"></label><br>
  <label>Period: <input id="period" value="2/1"></label><br>
  <label>UDP (e.g. 3|3(1)): <input id="udp" value="3|3(1)"></label><br>
  <label>Decimal places: <input id="decimals" type="number" value="4" min="0" max="10"></label><br>
  <button onclick="generateScale()">Generate Scale</button>
  <button onclick="playScale()">Play Scale</button>

  <table id="output" style="display:none">
    <thead>
      <tr><th>#</th><th>Cents</th><th>Ratio (approx.)</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let currentScaleCents = [];

    function parseInterval(input) {
      input = input.trim();
      if (input.includes('\\')) {
        const [steps, edo] = input.split('\\').map(Number);
        return 1200 * (steps / edo);
      } else if (input.includes('/')) {
        const [num, den] = input.split('/').map(Number);
        return 1200 * Math.log2(num / den);
      } else {
        return parseFloat(input); // assume cents
      }
    }

    function parseUDP(udpStr) {
      const match = udpStr.match(/(\d+)\|(\d+)\((\d+)\)/);
      if (!match) return null;
      return {
        up: parseInt(match[1]),
        down: parseInt(match[2]),
        periods: parseInt(match[3])
      };
    }

    function mod(a, b) {
      return ((a % b) + b) % b;
    }

    function ratioFromCents(cents) {
  const ratio = Math.pow(2, cents / 1200);
  const primeLimit = parseInt(document.getElementById("primeLimit").value);
  const fraction = approximateFraction(ratio, 1000, primeLimit);
  return fraction.num + "/" + fraction.den;
}

    function approximateFraction(x, maxDen = 1000, primeLimit = 7) {
  let a = Math.floor(x), h1 = 1, k1 = 0, h = a, k = 1;
  while (Math.abs(h / k - x) > 1e-10 && k < maxDen) {
    if (areFactorsWithinLimit(h, k, primeLimit)) {
      if (Math.abs(h / k - x) < 1e-4) {
        return { num: h, den: k };
      }
    }
    x = 1 / (x - a);
    a = Math.floor(x);
    const h2 = h1, k2 = k1;
    h1 = h; k1 = k;
    h = a * h1 + h2;
    k = a * k1 + k2;
  }
  return { num: h, den: k };
}


    function generateScale() {
      const generatorStr = document.getElementById("generator").value;
      const periodStr = document.getElementById("period").value;
      const udpStr = document.getElementById("udp").value;
      const decimals = parseInt(document.getElementById("decimals").value);

      const generator = parseInterval(generatorStr);
      const period = parseInterval(periodStr);
      const udp = parseUDP(udpStr);

      if (!udp) {
        alert("Invalid UDP format. Use format like '3|3(1)'.");
        return;
      }

      // Generate scale within one period
      const pitches = new Set();
      for (let i = -udp.down; i <= udp.up; i++) {
        const cents = i * generator;
        const wrapped = mod(cents, period);
        pitches.add(wrapped);
      }

      let scale = Array.from(pitches).sort((a, b) => a - b);
      scale.push(period * udp.periods); // Add final note P periods above base

      // If period < octave, tile scale to reach full octave (1200 cents)
      const fullScale = [];
      const octave = 1200;
      const repeats = Math.ceil(octave / period);

      for (let i = 0; i < repeats; i++) {
        const offset = i * period;
        for (let j = 0; j < scale.length; j++) {
          const note = scale[j] + offset;
          if (note <= octave) fullScale.push(note);
        }
      }

      currentScaleCents = fullScale;

      const tbody = document.querySelector("#output tbody");
      tbody.innerHTML = "";
      fullScale.forEach((cent, i) => {
        const row = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.textContent = i;
        const td2 = document.createElement("td");
        td2.textContent = cent.toFixed(decimals);
        const td3 = document.createElement("td");
        td3.textContent = ratioFromCents(cent);
        row.appendChild(td1);
        row.appendChild(td2);
        row.appendChild(td3);
        tbody.appendChild(row);
      });

      document.getElementById("output").style.display = "table";
    }

    function playScale() {
      if (!currentScaleCents.length) {
        alert("Generate a scale first!");
        return;
      }

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const baseFreq = 440; // A4

      currentScaleCents.forEach((cents, i) => {
        const freq = baseFreq * Math.pow(2, cents / 1200);
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "sine";
        osc.frequency.value = freq;
        gain.gain.value = 0.3;

        osc.connect(gain).connect(audioCtx.destination);
        const start = audioCtx.currentTime + i * 0.5;
        const stop = start + 0.45;
        osc.start(start);
        osc.stop(stop);
      });
    }
  </script>
</body>
</html>