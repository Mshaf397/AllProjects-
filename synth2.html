<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grid Web Synth — Full</title>
<style>
  :root { --pad:10px; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  body { margin: 0; padding: var(--pad); background: #f7f7f7; color:#111; }
  header { display:flex; gap:12px; align-items:center; margin-bottom:8px; }
  .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:end; background:#fff; padding:12px; border-radius:8px; box-shadow:0 1px 0 rgba(0,0,0,0.04); }
  label { font-size:13px; display:flex; flex-direction:column; min-width:120px; }
  input[type="number"], input[type="text"], select { padding:6px; font-size:14px; }
  button { padding:8px 12px; font-size:14px; cursor:pointer; }
  #gridWrap { margin-top:12px; border-radius:8px; overflow:auto; background:#fff; padding:8px; max-height:64vh; }
  canvas { display:block; background:#ffffff; border-radius:4px; }
  .small { font-size:12px; color:#555; }
  .status { margin-top:8px; font-size:13px; }
</style>
</head>
<body>
<header>
  <h2 style="margin:0">Grid Web Synth — Full</h2>
  <div class="small">Click/touch keys to play. Naming uses chain-of-fifths Fb → B#; only the simplest spelling is shown.</div>
</header>

<div class="controls">
  <label>Rows
    <input id="rows" type="number" min="1" max="500" value="6" />
  </label>

  <label>Cols
    <input id="cols" type="number" min="1" max="500" value="12" />
  </label>

  <label>Key size (px)
    <input id="keySize" type="number" min="8" max="200" value="64" />
  </label>

  <label>Tuning type
    <select id="tuningType">
      <option value="edo">EDO</option>
      <option value="nonoctave">Nonoctave (xedY)</option>
      <option value="ji">Just Intonation (prime limit)</option>
    </select>
  </label>

  <label id="edoParams">EDO steps
    <input id="edoSteps" type="number" min="2" max="4096" value="12" />
  </label>

  <label id="nonoParams" style="display:none">Nonoctave (format `xedY`, e.g. `13ed3` or `13ed3/2`)
    <input id="nonoSpec" type="text" placeholder="13ed3" value="13ed3" />
  </label>

  <label id="jiParams" style="display:none">Prime limit
    <input id="jiPrime" type="number" min="2" max="97" value="5" />
  </label>

  <label>Root note (name)
    <input id="rootNoteName" type="text" value="C4" />
  </label>

  <label>Root frequency (Hz)
    <input id="rootFreq" type="number" min="1" max="20000" value="261.6256" step="0.0001" />
  </label>

  <div style="display:flex;gap:8px;align-items:center;">
    <button id="applyBtn">Apply</button>
    <button id="randomizeBtn">Randomize</button>
  </div>

  <div style="flex:1"></div>

  <label>Waveform
    <select id="wave">
      <option>sine</option>
      <option>triangle</option>
      <option>sawtooth</option>
      <option>square</option>
    </select>
  </label>

  <label>Release (ms)
    <input id="release" type="number" min="5" max="10000" value="120" />
  </label>
</div>

<div id="gridWrap">
  <canvas id="gridCanvas"></canvas>
</div>

<div class="status">
  <div id="tuningText">Tuning: —</div>
  <div class="small" id="notesLegend"></div>
</div>

<script>
/* ===============================
   Grid Web Synth — Full Implementation
   Features implemented to your spec
   =============================== */

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioCtx.createGain();
masterGain.gain.value = 0.8;
masterGain.connect(audioCtx.destination);

const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', { alpha:false });

// UI elements
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const keySizeInput = document.getElementById('keySize');
const tuningType = document.getElementById('tuningType');
const edoStepsInput = document.getElementById('edoSteps');
const nonoParams = document.getElementById('nonoParams');
const nonoSpecInput = document.getElementById('nonoSpec');
const jiParams = document.getElementById('jiParams');
const jiPrimeInput = document.getElementById('jiPrime');
const rootFreqInput = document.getElementById('rootFreq');
const rootNoteNameInput = document.getElementById('rootNoteName');
const applyBtn = document.getElementById('applyBtn');
const randomizeBtn = document.getElementById('randomizeBtn');
const tuningText = document.getElementById('tuningText');
const notesLegend = document.getElementById('notesLegend');
const waveSel = document.getElementById('wave');
const releaseInput = document.getElementById('release');
const edoParams = document.getElementById('edoParams');

tuningType.addEventListener('change', () => {
  const v = tuningType.value;
  edoParams.style.display = v === 'edo' ? '' : 'none';
  nonoParams.style.display = v === 'nonoctave' ? '' : 'none';
  jiParams.style.display = v === 'ji' ? '' : 'none';
});

/* -------------------------
   Math & helpers
   ------------------------- */
function centsOfRatio(r){ return 1200 * Math.log2(r); }
function ratioFromCents(c){ return Math.pow(2, c/1200); }
function parseRatioString(s){
  s = String(s).trim();
  if(!s) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x.trim()));
    if(isFinite(a) && isFinite(b) && b!==0) return a/b;
    return NaN;
  } else {
    const v = parseFloat(s);
    return isFinite(v) ? v : NaN;
  }
}

/* -------------------------
   Chain-of-fifths canonical order (Fb → B#)
   This is the exact textual order you requested.
   ------------------------- */
const canonicalChainOfFifths = [
  "Fb","Cb","Gb","Db","Ab","Eb","Bb","F",
  "C","G","D","A","E","B","F#","C#",
  "G#","D#","A#","E#","B#"
];

/* -------------------------
   EDO note-name generation per spec
   - compute k = nearest integer to N * log2(3/2)
   - whole tone = stack two k's (2*k)
   - chromatic = stack seven k's minus 4 octaves => 7*k - 4*N
   - diatonic = wholeTone - chromatic
   - map canonical names Fb..B# using circle of fifths offsets,
     compute letters' base steps, apply accidentals (# or b) using diatonic step.
   - If multiple canonical spellings map to the same EDO step, we keep them internally
     and choose the "simplest" form when displaying.
   ------------------------- */

function generateEDONaming(N){
  // N is EDO size (integer >= 2)
  // compute k
  const kfloat = N * Math.log2(3/2);
  const k = Math.round(kfloat);
  // whole tone in EDO steps
  const wholeTone = (2 * k) % N;
  // chromatic semitone (7 fifths minus 4 octaves)
  const chromaticRaw = (7 * k) - (4 * N);
  // normalize chromatic to 0..N-1
  const chromatic = ((chromaticRaw % N) + N) % N;
  // diatonic semitone
  const diatonic = ((wholeTone - chromatic) % N + N) % N;

  // circle-of-fifths offsets (number of fifths from C)
  // We'll include offsets for letters A..G relative to C:
  const fifthOffsets = { 'C':0, 'G':1, 'D':2, 'A':3, 'E':4, 'B':5, 'F':-1 };
  // compute base step for each natural letter
  const letterSteps = {};
  for(const [L, offs] of Object.entries(fifthOffsets)){
    let pos = (offs * k) % N;
    pos = (pos + N) % N;
    letterSteps[L] = pos;
  }

  // helper: convert canonical name like "Cb" or "F#" to an EDO step
  function canonicalNameToStep(name){
    // letter is first char A-G
    const letter = name[0];
    const rest = name.slice(1);
    let base = letterSteps[letter] ?? 0;
    for(const ch of rest){
      if(ch === '#') base = (base + diatonic) % N;
      else if(ch === 'b') base = (base - diatonic + N) % N;
      else {
        // ignore other chars
      }
    }
    return (base + N) % N;
  }

  // Map steps -> list of canonical names that map there
  const stepToCanonicalNames = new Map();
  for(const cname of canonicalChainOfFifths){
    const s = canonicalNameToStep(cname);
    if(!stepToCanonicalNames.has(s)) stepToCanonicalNames.set(s, []);
    stepToCanonicalNames.get(s).push(cname);
  }

  // Now, fill all N steps with names.
  // For steps covered by at least one canonical name, store the list found.
  // For other steps, derive a name by taking nearest canonical step and adding ^ or v prefixes.
  // We'll compute the nearest canonical step (circular distance small) and produce a name with repeated ^/v.
  const canonicalSteps = Array.from(stepToCanonicalNames.keys());
  function circularDist(a,b){
    const d = Math.abs(a - b);
    return Math.min(d, N - d);
  }

  const names = Array.from({length:N}, ()=>[]);
  // assign canonical lists
  for(const [s, list] of stepToCanonicalNames.entries()){
    names[s] = [...new Set(list)];
  }

  // For each step without canonical assignment, find nearest canonical step and annotate with ^ or v
  for(let s=0; s<N; s++){
    if(names[s].length > 0) continue;
    // find nearest canonical step (tie-breaker: smallest positive signed distance)
    let best = null;
    let bestAbs = Infinity;
    let bestSigned = 0;
    let bestCanonicalStep = null;
    for(const cs of canonicalSteps){
      // compute signed minimal distance from cs to s in range -N/2..N/2
      let signed = ((s - cs + N) % N);
      if(signed > N/2) signed -= N; // now signed is -N/2..N/2
      const absd = Math.abs(signed);
      if(absd < bestAbs){
        bestAbs = absd;
        bestSigned = signed;
        bestCanonicalStep = cs;
      }
    }
    // for each canonical name at bestCanonicalStep, build a prefixed name
    const baseNames = stepToCanonicalNames.get(bestCanonicalStep) || ['?'];
    const prefList = baseNames.map(bn => {
      if(bestSigned > 0) return '^'.repeat(bestSigned) + bn;
      if(bestSigned < 0) return 'v'.repeat(-bestSigned) + bn;
      return bn;
    });
    names[s] = prefList;
  }

  // return structure with step->arrayOfNames, plus stepInfo for debugging
  return { names, info: {k, wholeTone, chromatic: chromaticRaw, diatonic} };
}

/* -------------------------
   Pick simplest name from array of candidate names
   Rule implemented:
   1) Prefer name without any '^' or 'v' prefix (no EDOstep annotations)
   2) Among those, prefer pure natural (A..G), then single sharp, then single flat, then prefer fewer accidentals
   3) If none without ^/v, prefer minimal number of prefixes, and apply rule 2 for remainder
   4) Last resort — return first
   ------------------------- */
function pickSimplestName(list){
  if(!Array.isArray(list) || list.length===0) return '?';
  // normalize input
  const uniq = Array.from(new Set(list));
  // helper to remove prefix ^/v and count prefixes
  function analyze(n){
    let prefixCount = 0;
    while(n[0] === '^' || n[0] === 'v'){ prefixCount++; n = n.slice(1); }
    const core = n;
    const isNatural = /^[A-G]$/.test(core);
    const sharps = (core.match(/#/g)||[]).length;
    const flats = (core.match(/b/g)||[]).length;
    const accidentalCount = sharps + flats;
    const kindScore = isNatural ? 0 : (sharps>0 ? 1 : (flats>0 ? 2 : 3));
    return {orig:n, full:n, prefixCount, isNatural, sharps, flats, accidentalCount, kindScore, displayCore:core, raw: n};
  }
  // prefer candidates with prefixCount = 0 first
  const analyzed = uniq.map(s => ({s, a: analyze(s)}));
  analyzed.sort((A,B)=>{
    // 1) prefixCount (prefer 0)
    if(A.a.prefixCount !== B.a.prefixCount) return A.a.prefixCount - B.a.prefixCount;
    // 2) prefer naturals (kindScore smaller better)
    if(A.a.kindScore !== B.a.kindScore) return A.a.kindScore - B.a.kindScore;
    // 3) fewer accidentals
    if(A.a.accidentalCount !== B.a.accidentalCount) return A.a.accidentalCount - B.a.accidentalCount;
    // 4) fewer prefix if same
    if(A.a.prefixCount !== B.a.prefixCount) return A.a.prefixCount - B.a.prefixCount;
    // 5) shorter overall string
    if(A.s.length !== B.s.length) return A.s.length - B.s.length;
    // fallback lexicographic
    return A.s.localeCompare(B.s);
  });
  return analyzed[0].s;
}

/* -------------------------
   Nonoctave: parse xedY and find EDO that approximates a single step
   Implementation per spec:
   1) parse xedY => x integer and Y ratio
   2) stepRatio = Y^(1/x)
   3) iterate M from 13..4096, compute raw = M * log2(stepRatio), s = round(raw)
      If |raw - s| <= 0.1 then accept (within 10% of an EDO step)
   4) return smallest M that matches; also return s (steps in M that correspond to a single nonoctave step)
   ------------------------- */
function parseNonoSpec(spec){
  const m = String(spec).trim().match(/^(\d+)\s*ed\s*(.+)$/i);
  if(!m) return null;
  const x = parseInt(m[1],10);
  const ratio = parseRatioString(m[2]);
  if(!isFinite(ratio) || ratio <= 0) return null;
  return {x, ratio};
}

function findEDOApproxForNono(x, ratio){
  const stepRatio = Math.pow(ratio, 1 / x);
  const stepCents = centsOfRatio(stepRatio);
  let best = null;
  for(let M=13; M<=4096; M++){
    const raw = M * Math.log2(stepRatio);
    const s = Math.round(raw);
    const err = Math.abs(raw - s);
    if(err <= 0.1){ // within 10% of an EDOstep as requested
      return {M, s, raw, err, stepCents};
    }
    if(!best || err < best.err) best = {M, s, raw, err, stepCents};
  }
  return best;
}

/* -------------------------
   Just Intonation generator by prime limit
   - produce ratios in [1,2)
   - enumerate small numerator/denominator and filter by prime factors
   - sort by cents ascending
   ------------------------- */
function primesUpTo(n){
  const sieve = new Array(n+1).fill(true);
  sieve[0]=sieve[1]=false;
  for(let p=2;p*p<=n;p++) if(sieve[p]) for(let q=p*p;q<=n;q+=p) sieve[q]=false;
  const ps=[];
  for(let i=2;i<=n;i++) if(sieve[i]) ps.push(i);
  return ps;
}
function factorOk(n, allowedPrimes){
  let m = Math.abs(Math.round(n));
  if(m===0) return false;
  for(const p of allowedPrimes){
    while(m % p === 0) m = m / p;
  }
  return m === 1;
}
function generateJIRatios(primeLimit, maxNumDen=16){
  const allowedPrimes = primesUpTo(primeLimit);
  const ratios = new Set();
  for(let num=1; num<=maxNumDen; num++){
    if(!factorOk(num, allowedPrimes)) continue;
    for(let den=1; den<=maxNumDen; den++){
      if(!factorOk(den, allowedPrimes)) continue;
      let r = num / den;
      // reduce into [1,2)
      while(r >= 2) r /= 2;
      while(r < 1) r *= 2;
      if(r >=1 && r < 2) ratios.add(r);
    }
  }
  const arr = Array.from(ratios).sort((a,b)=>centsOfRatio(a) - centsOfRatio(b));
  return arr;
}

/* -------------------------
   Global grid/tuning state
   ------------------------- */
let gridState = {
  rows: 6,
  cols: 12,
  keySize: 64,
  tuning: { type: 'edo', edo: 12 },
  rootFreq: 261.6256,
  rootName: 'C4',
  edoNameTable: null, // for EDO naming: array of arrays (step -> canonical names)
  nonoInfo: null,     // for nonoctave: {x, ratio, approx {M,s}}
  jiRatios: null
};

function buildStateFromUI(){
  const rows = Math.max(1, Math.min(500, parseInt(rowsInput.value) || 6));
  const cols = Math.max(1, Math.min(500, parseInt(colsInput.value) || 12));
  const keySize = Math.max(8, Math.min(200, parseInt(keySizeInput.value) || 64));
  const rootFreq = Math.max(1, Math.min(20000, parseFloat(rootFreqInput.value) || 261.6256));
  const rootName = rootNoteNameInput.value || 'root';
  const type = tuningType.value;

  gridState.rows = rows;
  gridState.cols = cols;
  gridState.keySize = keySize;
  gridState.rootFreq = rootFreq;
  gridState.rootName = rootName;

  if(type === 'edo'){
    const N = Math.max(2, Math.min(4096, parseInt(edoStepsInput.value) || 12));
    gridState.tuning = { type:'edo', edo: N };
    const ed = generateEDONaming(N);
    gridState.edoNameTable = ed.names; // array step->arrayOfNames
    gridState.nonoInfo = null;
    gridState.jiRatios = null;
    tuningText.textContent = `${N}-EDO (names generated from chain-of-fifths)`;
  } else if(type === 'nonoctave'){
    const parsed = parseNonoSpec(nonoSpecInput.value);
    if(!parsed){ alert('Invalid nonoctave spec. Use format xedY, e.g. 13ed3 or 13ed3/2'); return false; }
    const approx = findEDOApproxForNono(parsed.x, parsed.ratio);
    gridState.tuning = { type:'nonoctave', x: parsed.x, ratio: parsed.ratio };
    gridState.nonoInfo = { parsed, approx };
    if(approx && approx.M){
      // use the EDO M for name generation, as the spec requires
      const ed = generateEDONaming(approx.M);
      gridState.edoNameTable = ed.names;
      tuningText.textContent = `${parsed.x}ed${parsed.ratio} → approx ${approx.M}-EDO (step ≈ ${approx.s}). Names from ${approx.M}-EDO.`;
    } else {
      // no good EDO — still synthesize names with best candidate
      const ed = generateEDONaming(31); // fallback arbitrary
      gridState.edoNameTable = ed.names;
      tuningText.textContent = `${parsed.x}ed${parsed.ratio} (no close EDO found)`;
    }
    gridState.jiRatios = null;
  } else if(type === 'ji'){
    const p = Math.max(2, Math.min(97, parseInt(jiPrimeInput.value) || 5));
    gridState.tuning = { type:'ji', prime: p };
    const ratios = generateJIRatios(p, 20);
    gridState.jiRatios = ratios;
    gridState.edoNameTable = null;
    gridState.nonoInfo = null;
    tuningText.textContent = `JI (prime limit ${p}) — ${ratios.length} ratios generated`;
  } else {
    return false;
  }
  return true;
}

/* -------------------------
   Frequency mapping for index
   index = linear index across grid: idx = row*cols + col
   EDO: f = root * 2^(idx / E)
   Nonoctave: stepRatio = ratio^(1/x); f = root * stepRatio^idx
     for naming: we map nonoctave index -> EDO step by using approx.s (every s EDO steps)
   JI: Map repeating ratios across grid: pick ratio = jiRatios[idx % len] * 2^octaveShift
   ------------------------- */
function frequencyForIndex(idx){
  const t = gridState.tuning;
  const root = gridState.rootFreq;
  if(t.type === 'edo'){
    const E = t.edo;
    return root * Math.pow(2, idx / E);
  } else if(t.type === 'nonoctave'){
    const { x, ratio } = t;
    const stepRatio = Math.pow(ratio, 1/x);
    return root * Math.pow(stepRatio, idx);
  } else if(t.type === 'ji'){
    const ratios = gridState.jiRatios || [1];
    if(ratios.length === 0) return root;
    const len = ratios.length;
    const step = idx % len;
    const octaveShift = Math.floor(idx / len);
    return root * ratios[step] * Math.pow(2, octaveShift);
  }
  return root;
}

/* -------------------------
   Label generation for index (display only)
   - For EDO: map idx modulo E -> pick simplest name from edoNameTable[step]
   - For nonoctave: use approx.s mapping: nama = edoNameTable[(idx * s) % M]
   - For JI: display ratio string (pretty)
   ------------------------- */
function prettyRatioName(r){
  // try to find small integer fraction
  const maxDen = 64;
  let best = {err:Infinity, n:1, d:1};
  for(let d=1; d<=maxDen; d++){
    const n = Math.round(r*d);
    const err = Math.abs(r - n/d);
    if(err < best.err){ best = {err, n, d}; if(err === 0) break; }
  }
  return `${best.n}/${best.d} (${centsOfRatio(r).toFixed(2)}c)`;
}

function nameForIndex(idx){
  const t = gridState.tuning;
  if(t.type === 'edo'){
    const E = t.edo;
    const step = ((idx % E) + E) % E;
    const candidates = gridState.edoNameTable[step] || [];
    return pickSimplestName(candidates);
  } else if(t.type === 'nonoctave'){
    const info = gridState.nonoInfo;
    if(info && info.approx && info.approx.M && typeof info.approx.s === 'number'){
      const M = info.approx.M;
      const s = info.approx.s;
      const step = (( (idx * s) % M ) + M) % M; // use every s-th step
      const candidates = gridState.edoNameTable[step] || [];
      return pickSimplestName(candidates);
    } else {
      // fallback to showing step number
      return `step ${idx}`;
    }
  } else if(t.type === 'ji'){
    const ratios = gridState.jiRatios || [1];
    if(ratios.length === 0) return '?';
    const step = idx % ratios.length;
    return prettyRatioName(ratios[step]);
  }
  return '?';
}

/* -------------------------
   Canvas drawing
   ------------------------- */
function resizeCanvas(){
  const ks = gridState.keySize;
  const width = gridState.cols * ks;
  const height = gridState.rows * ks;
  canvas.width = width;
  canvas.height = height;
  // set visible size reasonable for viewport
  canvas.style.width = Math.min(width, window.innerWidth - 40) + 'px';
  canvas.style.height = Math.min(height, window.innerHeight * 0.64) + 'px';
}

function renderGrid(){
  const ks = gridState.keySize;
  const rows = gridState.rows;
  const cols = gridState.cols;

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for(let r=0; r<rows; r++){
    for(let c=0; c<cols; c++){
      const x = c*ks;
      const y = r*ks;
      // key background
      ctx.fillStyle = '#fff';
      ctx.fillRect(x,y,ks,ks);
      ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);

      const idx = r*cols + c;
      const label = nameForIndex(idx);

      // draw label, truncate if long
      ctx.fillStyle = '#111';
      let disp = String(label);
      if(disp.length > 14) disp = disp.slice(0,12) + '…';
      ctx.fillText(disp, x + ks/2, y + ks/2);
    }
  }
}

/* -------------------------
   Audio: simple polyphonic oscillator per pressed key
   - activeVoices: Map keyId -> {osc, gain}
   ------------------------- */
const activeVoices = new Map();

function noteOn(idx){
  if(audioCtx.state === 'suspended') audioCtx.resume();
  if(activeVoices.has(idx)) return;
  const osc = audioCtx.createOscillator();
  osc.type = waveSel.value || 'sine';
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(1.0, audioCtx.currentTime + 0.01);
  osc.connect(g);
  g.connect(masterGain);
  const f = frequencyForIndex(idx);
  osc.frequency.value = f;
  osc.start();
  activeVoices.set(idx, {osc, gain: g});
}

function noteOff(idx){
  const v = activeVoices.get(idx);
  if(!v) return;
  const rel = Math.max(5, parseFloat(releaseInput.value) || 120) / 1000;
  const now = audioCtx.currentTime;
  try {
    v.gain.gain.cancelScheduledValues(now);
    v.gain.gain.setValueAtTime(v.gain.gain.value, now);
    v.gain.gain.exponentialRampToValueAtTime(0.0001, now + rel);
    v.osc.stop(now + rel + 0.02);
  } catch(e){}
  setTimeout(()=> {
    try { v.osc.disconnect(); v.gain.disconnect(); } catch(e){}
  }, (rel + 0.05) * 1000);
  activeVoices.delete(idx);
}

/* -------------------------
   Input handling: pointer events on canvas
   - supports dragging across keys
   ------------------------- */
function canvasPosToIndex(evt){
  const rect = canvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  const c = Math.floor(x / gridState.keySize);
  const r = Math.floor(y / gridState.keySize);
  if(c < 0 || c >= gridState.cols || r < 0 || r >= gridState.rows) return null;
  return r * gridState.cols + c;
}

let pointerDownIdx = null;

canvas.addEventListener('pointerdown', (e) => {
  if(audioCtx.state === 'suspended') audioCtx.resume();
  const idx = canvasPosToIndex(e);
  if(idx === null) return;
  pointerDownIdx = idx;
  noteOn(idx);
  drawKeyActive(idx, true);
  e.preventDefault();
});
canvas.addEventListener('pointermove', (e) => {
  if(pointerDownIdx === null) return;
  const idx = canvasPosToIndex(e);
  if(idx !== pointerDownIdx){
    if(pointerDownIdx !== null) { noteOff(pointerDownIdx); drawKeyActive(pointerDownIdx, false); }
    if(idx !== null){ noteOn(idx); drawKeyActive(idx, true); }
    pointerDownIdx = idx;
  }
});
canvas.addEventListener('pointerup', (e) => {
  if(pointerDownIdx !== null){ noteOff(pointerDownIdx); drawKeyActive(pointerDownIdx, false); pointerDownIdx = null; }
});
canvas.addEventListener('pointerleave', (e) => {
  if(pointerDownIdx !== null){ noteOff(pointerDownIdx); drawKeyActive(pointerDownIdx, false); pointerDownIdx = null; }
});
canvas.addEventListener('click', (e) => {
  const idx = canvasPosToIndex(e);
  if(idx === null) return;
  noteOn(idx);
  drawKeyActive(idx, true);
  setTimeout(()=>{ noteOff(idx); drawKeyActive(idx,false); }, 220);
});

function drawKeyActive(idx, active){
  const ks = gridState.keySize;
  const r = Math.floor(idx / gridState.cols);
  const c = idx % gridState.cols;
  const x = c*ks;
  const y = r*ks;
  if(active){
    ctx.fillStyle = '#e6f7ff'; // light highlight
    ctx.fillRect(x+1,y+1,ks-2,ks-2);
  } else {
    ctx.fillStyle = '#fff';
    ctx.fillRect(x+1,y+1,ks-2,ks-2);
  }
  ctx.strokeStyle = '#ddd';
  ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);

  // redraw label
  const lab = nameForIndex(idx);
  ctx.fillStyle = '#111';
  ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let disp = String(lab);
  if(disp.length > 14) disp = disp.slice(0,12) + '…';
  ctx.fillText(disp, x + ks/2, y + ks/2);
}

/* -------------------------
   Buttons
   ------------------------- */
applyBtn.addEventListener('click', () => {
  const ok = buildStateFromUI();
  if(!ok) return;
  resizeCanvas();
  renderGrid();
  updateLegend();
});

randomizeBtn.addEventListener('click', () => {
  const t = tuningType.value;
  if(t === 'edo'){
    const v = Math.floor(5 + Math.random()*48);
    edoStepsInput.value = v;
  } else if(t === 'nonoctave'){
    const x = Math.floor(5 + Math.random()*40);
    const rnum = [3,5,7,9,2,4][Math.floor(Math.random()*6)];
    nonoSpecInput.value = `${x}ed${rnum}`;
  } else {
    jiPrimeInput.value = [3,5,7,11,13,17][Math.floor(Math.random()*6)];
  }
  const ok = buildStateFromUI();
  if(!ok) return;
  resizeCanvas();
  renderGrid();
  updateLegend();
});

/* -------------------------
   Legend / status update
   ------------------------- */
function updateLegend(){
  const t = gridState.tuning;
  let txt = `Grid: ${gridState.rows}×${gridState.cols} • Key size: ${gridState.keySize}px • Root: ${gridState.rootName} @ ${gridState.rootFreq} Hz. `;
  if(t.type === 'edo') txt += `${t.edo}-EDO (names generated Fb→B#).`;
  else if(t.type === 'nonoctave'){
    const ni = gridState.nonoInfo;
    txt += `${t.x}ed${t.ratio}. `;
    if(ni && ni.approx) txt += `Approx: ${ni.approx.M}-EDO, s=${ni.approx.s} (error ${ni.approx.err?.toFixed(4) ?? 'n/a'}).`;
    else txt += 'No close EDO approximation found.';
  } else if(t.type === 'ji'){
    txt += `JI (prime ≤ ${t.prime}), ${ (gridState.jiRatios||[]).length } ratios generated.`;
  }
  notesLegend.textContent = txt;
}

/* -------------------------
   Initialization: build once
   ------------------------- */
buildStateFromUI();
resizeCanvas();
renderGrid();
updateLegend();

window.addEventListener('resize', () => { resizeCanvas(); renderGrid(); });

</script>
</body>
</html>