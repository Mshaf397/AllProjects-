<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grid Web Synth — Extreme Power Edition V2</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    /* LIGHT MODE (Default) */
    --pad: 10px;
    --main-bg: #1E90FF; /* DodgerBlue */
    --control-bg: #323ddd;
    --text-color: #f1f1f1;
    --button-color: #12e34b; /* Bright green */
    --key-color: #228222; /* ForestGreen */
    --key-text-color: #111;
    --key-active: #ffcc00; /* Yellow */
    --key-inactive: rgba(255,255,255,0.9);
    --modal-bg: white;
    --modal-text-color: #111;
    --input-bg: white;
    font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    transition: background-color 0.3s;
  }
  
  /* DARK MODE OVERRIDES */
  .dark-mode {
    --main-bg: #111827; /* Dark Gray */
    --control-bg: #2C003E; /* Deep Violet */
    --text-color: #e5e7eb; /* Light text */
    --button-color: #BB86FC; /* Light Purple/Magenta */
    --key-color: #6200EE; /* Medium Violet */
    --key-text-color: #e5e7eb;
    --key-active: #FF6E40; /* Vibrant Orange */
    --key-inactive: rgba(255,255,255,0.1);
    --modal-bg: #1f2937;
    --modal-text-color: #e5e7eb;
    --input-bg: #374151;
  }
  
  /* EXTREME MODE OVERRIDES (Red/Black Cyberpunk) */
  .extreme-mode {
    --main-bg: #000000; 
    --control-bg: #111111;
    --text-color: #FF0033; /* Neon Red */
    --button-color: #00FF99; /* Neon Green/Cyan */
    --key-color: #330000; /* Dark Red */
    --key-text-color: #00FF99;
    --key-active: #FF6600; /* Orange/Gold */
    --key-inactive: rgba(255,0,51,0.15); /* Faint Red */
    --modal-bg: #222222;
    --modal-text-color: #00FF99;
    --input-bg: #330000;
  }
  .extreme-mode input[type="range"]::-webkit-slider-thumb {
      background: var(--button-color);
  }


  body {
    margin: 0;
    padding: var(--pad);
    background: var(--main-bg);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
  }

  header {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 8px;
    justify-content: space-between;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: end;
    background: var(--control-bg);
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    transition: background-color 0.3s;
  }

  label {
    font-size: 13px;
    display: flex;
    flex-direction: column;
    min-width: 120px;
    color: var(--text-color);
  }

  input[type="range"] {
    height: 30px;
    cursor: grab;
  }

  input[type="number"],
  input[type="text"],
  select {
    padding: 6px;
    font-size: 14px;
    border-radius: 4px;
    color: var(--key-text-color);
    background-color: var(--input-bg);
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-top: 5px;
      background-color: var(--input-bg);
      border: 1px solid rgba(255,255,255,0.3);
  }

  select[multiple] {
    padding: 4px;
    border: 1px solid rgba(255,255,255,0.2);
    background: var(--input-bg);
    min-height: 100px;
    box-sizing: border-box;
    color: var(--key-text-color);
  }
  
  /* Style for multiple select options */
  select[multiple] option {
    background: var(--input-bg);
    color: var(--key-text-color);
  }
  select[multiple] option:checked {
    background: var(--button-color);
    color: #111;
  }


  button {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    border-radius: 4px;
    background: var(--button-color);
    color: var(--control-bg);
    border: none;
    font-weight: bold;
    transition: background 0.1s, transform 0.1s, color 0.3s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  button:hover {
    filter: brightness(1.2);
    transform: translateY(-1px);
  }
  
  /* Recording Button Styles */
  #recordBtn {
    background: #FF4136; /* Red for recording */
    color: white;
  }
  
  #stopRecordBtn {
    background: #FFDC00; /* Yellow for stop */
    color: #111;
  }
  
  /* Extreme Mode Toggle Specific Styles */
  #extremeModeToggle {
      min-width: unset;
      padding: 6px 10px;
      background: #FF4500; /* OrangeRed */
      color: white;
  }
  .extreme-mode #extremeModeToggle {
      background: var(--text-color); /* Neon Red */
      color: black;
  }


  #gridWrap {
    margin-top: 12px;
    border-radius: 8px;
    overflow: auto;
    background: var(--control-bg);
    padding: 8px;
    max-height: 60vh; 
    max-width: 100%;
    transition: background-color 0.3s;
  }
  @media (max-width: 768px) {
    #gridWrap {
      max-height: 40vh;
    }
    .controls label {
        min-width: 100px;
    }
  }

  canvas {
    display: block;
    background: var(--key-color);
    border-radius: 4px;
    width: auto; 
    height: auto;
    transition: background-color 0.3s;
    touch-action: none; /* Crucial for preventing scroll on touch events */
  }

  .small {
    font-size: 12px;
    color: var(--button-color);
    transition: color 0.3s;
  }
  
  .status {
    margin-top: 12px;
    color: var(--text-color);
    padding: 8px;
    border-radius: 4px;
    background: rgba(0,0,0,0.2);
    transition: color 0.3s;
  }
  
  /* Status indicators */
  .recording-status {
      font-weight: bold;
      color: #FF4136; /* Red */
      animation: pulse 1s infinite alternate;
  }

  @keyframes pulse {
      from { opacity: 1; }
      to { opacity: 0.5; }
  }


  /* MODAL STYLES */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: var(--modal-bg);
    padding: 24px;
    border-radius: 8px;
    width: 90%;
    max-width: 600px;
    color: var(--modal-text-color);
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    font-size: 16px;
    transition: background-color 0.3s, color 0.3s;
  }
  .modal-content h3 {
    margin-top: 0;
    color: var(--control-bg);
  }
  .dark-mode .modal-content h3, .extreme-mode .modal-content h3 {
     color: var(--button-color);
  }
  .modal-content .modal-controls {
    display: flex;
    justify-content: flex-end;
    margin-top: 20px;
    gap: 10px;
  }
  .modal-content label {
      color: var(--modal-text-color);
      margin-bottom: 8px;
      font-size: 14px;
  }
  .modal-content input {
      width: 100%;
      box-sizing: border-box;
      color: var(--modal-text-color);
      font-size: 14px;
      background-color: var(--input-bg);
  }
  
  /* Dark Mode Toggle Button Specific Styles */
  #darkModeToggle {
      min-width: unset;
      padding: 6px 10px;
      font-size: 12px;
  }
  
  /* Layout for ADSR/LFO/Delay */
  .fx-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
  }
  .fx-group h4 {
      margin: 0;
      font-size: 14px;
      color: var(--button-color);
  }
</style>
</head>
<body>
<header>
  <div class="flex items-center gap-3">
    <h2 style="margin:0">Grid Web Synth — Extreme Power Edition V2</h2>
    <div class="small">Scale generation uses the currently selected EDO Steps (N) for quantization.</div>
  </div>
  <div class="flex gap-2">
      <button id="extremeModeToggle" title="Toggle Extreme/Standard Mode">EXTREME MODE</button>
      <button id="darkModeToggle" title="Toggle Dark/Light Mode">Enable Dark Mode</button>
  </div>
</header>

<div class="controls">
  <!-- HYPER SCALE CONTROLS -->
  <label>Rows (Max 4.2B)
    <input id="rows" type="number" min="1" max="4294967296" value="6" />
  </label>

  <label>Cols (Max 4.2B)
    <input id="cols" type="number" min="1" max="4294967296" value="12" />
  </label>

  <label>Key size (px)
    <input id="keySize" type="number" min="8" max="512" value="64" />
  </label>
  
  <!-- ADVANCED MAPPING CONTROLS -->
  <label title="1-indexed, starting from top-left (1), wrapping by row">Root Key Index
    <input id="rootKeyIndex" type="number" min="1" max="4294967296" value="1" />
  </label>
  <label title="Row Offset (affects key at 1,1)">Row Offset (steps)
    <input id="rOffset" type="number" min="-1000" max="1000" value="0" />
  </label>
  <label title="Col Offset (affects key at 1,1)">Col Offset (steps)
    <input id="cOffset" type="number" min="-1000" max="1000" value="0" />
  </label>

  <label title="Interval in scale degrees/EDO steps for one column to the right.">Horizontal Steps
    <input id="hSteps" type="number" min="-100" max="100" value="1" />
  </label>

  <label title="Interval in scale degrees/EDO steps for one row down.">Vertical Steps
    <input id="vSteps" type="number" min="-100" max="100" value="7" />
  </label>
  
  <label title="Interval in scale degrees/EDO steps for one key diagonally down-right.">Diagonal Steps
    <input id="dSteps" type="number" min="-100" max="100" value="8" />
  </label>
  <!-- END ADVANCED MAPPING CONTROLS -->

  <label>Tuning type
    <select id="tuningType">
      <option value="edo">EDO</option>
      <option value="nonoctave">Nonoctave (xedY cents)</option>
      <option value="ji">Just Intonation (Prime Limit)</option>
    </select>
  </label>

  <label id="edoParams">EDO steps (N)
    <input id="edoSteps" type="number" min="2" max="4294967296" value="12" />
  </label>

  <!-- Nonoctave Inputs -->
  <label id="nonoParams" style="display:none">Nonoctave (format `xedY`, e.g. `13ed300`):
    <input id="nonoSpec" type="text" placeholder="13ed300" value="13ed300" />
  </label>

  <!-- JI Inputs -->
  <label id="jiParams" style="display:none">Prime limit
    <input id="jiPrime" type="number" min="3" max="97" value="5" />
  </label>

  <label>Root note (name)
    <input id="rootNoteName" type="text" value="C4" />
  </label>

  <label>Root frequency (Hz)
    <input id="rootFreq" type="number" min="1" max="20000" value="261.6256" step="0.0001" />
  </label>

  <label style="min-width: 250px;">Scale Subset (Select Notes)
    <select id="scaleSubset" multiple size="6"></select>
    <div class="small mt-1">(Hold Ctrl/Cmd to select multiple)</div>
  </label>
  
  <label style="min-width: 150px;">Start Step (Mode)
    <select id="modeSelector"></select>
  </label>
  
  <div style="display:flex;flex-direction:column;gap:8px;align-items:start;">
    <div style="display:flex;gap:8px;">
        <button id="applyBtn">Apply Grid & Tuning</button>
        <button id="stopAllBtn" title="Stop all playing voices">Stop All</button>
    </div>
    <button id="generateScaleBtn">Generate Scale Subset</button>
  </div>
  
  <div style="flex:1; min-width: 10px;"></div>
  
  <!-- HYPER SYNTH CONTROLS -->
  <label title="Number of stacked oscillators per key press (Unison)">Unison Voices (Max 16)
    <input id="unisonVoices" type="number" min="1" max="16" value="3" />
  </label>
  <label title="Max detuning of unison voices in cents (e.g., 5 cents)">Detune (Cents)
    <input id="detuneCents" type="number" min="0" max="100" step="0.01" value="5" />
  </label>
  <label title="If checked, notes are quantized to the Scale Subset (mode). If unchecked, the key position maps to the full EDO/JI steps.">Quantize to Subset
    <input id="quantizeToggle" type="checkbox" checked />
  </label>
  <!-- END HYPER SYNTH CONTROLS -->
  
  <!-- FX GROUP -->
  <div class="fx-group w-full md:w-1/4">
      <h4>ADSR Envelope (Seconds)</h4>
      <div class="flex gap-2 w-full flex-wrap">
        <label style="min-width: 50px;">A
          <input id="attack" type="number" min="0.001" max="5.0" step="0.001" value="0.005" />
        </label>
        <label style="min-width: 50px;">D
          <input id="decay" type="number" min="0.001" max="5.0" step="0.001" value="0.1" />
        </label>
        <label style="min-width: 50px;">S (Level)
          <input id="sustainLevel" type="number" min="0.0" max="1.0" step="0.01" value="0.7" />
        </label>
        <label style="min-width: 50px;">R
          <input id="release" type="number" min="0.005" max="30.0" step="0.001" value="0.5" />
        </label>
      </div>
      
      <h4 class="mt-2">LFO (Vibrato)</h4>
      <div class="flex gap-2 w-full flex-wrap">
        <label style="min-width: 70px;">Rate (Hz)
            <input id="lfoRate" type="number" min="0.01" max="20" step="0.01" value="5.0" />
        </label>
        <label style="min-width: 70px;">Depth (Cents)
            <input id="lfoDepth" type="number" min="0" max="50" step="0.1" value="10" />
        </label>
      </div>
  </div>
  
  <div class="fx-group w-full md:w-1/4">
      <h4>Master Delay FX</h4>
      <label>Delay Time (s)
        <input id="delayTime" type="range" min="0.01" max="2.0" step="0.01" value="0.4" />
      </label>
      <label>Feedback
        <input id="delayFeedback" type="range" min="0.0" max="0.95" step="0.01" value="0.6" />
      </label>
      <label>Mix (Wet)
        <input id="delayWet" type="range" min="0.0" max="1.0" step="0.01" value="0.3" />
      </label>
      
      <label class="mt-2">Waveform
        <select id="wave">
          <option>sine</option>
          <option>triangle</option>
          <option>sawtooth</option>
          <option>square</option>
          <option>piano</option>
          <option>guitar</option>
          <option>violin</option>
          <option>organ</option>
          <option>electric_guitar</option>
        </select>
      </label>
  </div>
  <!-- END FX GROUP -->


  <!-- Volume Slider -->
  <label>Master Volume
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.8" />
  </label>

  <!-- Sustain Toggle (Now irrelevant due to ADSR, but kept for legacy UI) -->
  <label>Sustain (Hold)
    <input id="sustainToggle" type="checkbox" checked />
  </label>


  <!-- AUDIO RECORDING CONTROLS -->
  <div class="flex flex-col gap-2">
      <button id="recordBtn" class="!px-4">
          <span id="recordText">Record</span>
      </button>
      <button id="stopRecordBtn" disabled class="!px-4">Stop</button>
  </div>
  <!-- END AUDIO RECORDING CONTROLS -->
  
</div>

<div id="gridWrap">
  <canvas id="gridCanvas"></canvas>
</div>

<div class="status">
  <div id="tuningText">Tuning: —</div>
  <div class="small" id="notesLegend"></div>
  <div class="small mt-1">
      <span id="keyboardHint">Keyboard Input: QWERTY home row keys are mapped to the first 24 keys (Z, S, X, ... Q, 2, W...).</span>
      <span id="recordingStatus"></span>
      <span id="recordingHint">The recorder exports as **WAV audio** (uncompressed, lossless quality).</span>
  </div>
</div>

<!-- SCALE GENERATOR MODAL -->
<div id="scaleGeneratorModal" class="modal-overlay">
    <div class="modal-content">
        <h3>Circle-of-Fifths Scale Generator</h3>
        <p class="small" style="color:#666;">This tool only works with **EDO** tuning and uses the current **EDO Steps (N)** value for quantization.</p>

        <label>Generator (Ratio x/y, Cents, or EDO Steps x\y, e.g., 3/2 or 7\12):
          <input id="gen_generator" value="700">
        </label>
        <label>Period (Ratio x/y, Cents, or EDO Steps x\y, eg., 2/1 or 12\12):
          <input id="gen_period" value="1200">
        </label>
        <label>UDP (e.g., up|down(periods), like 3|3(1)):
          <input id="gen_udp" value="3|3(1)">
        </label>

        <div class="modal-controls">
            <button id="gen_cancelBtn" style="background:#ccc; color:#333;">Cancel</button>
            <button id="gen_applyBtn">Generate & Apply</button>
        </div>
    </div>
</div>
<!-- /MODAL -->

<script>
let gridState = {
  rows: 6, cols: 12, keySize: 64,
  rootKeyIndex: 1, 
  rOffset: 0, cOffset: 0, 
  hSteps: 1, 
  vSteps: 7, 
  dSteps: 8, 
  tuning: { type:'edo', edo: 12 },
  rootFreq: 261.6256, rootName: 'C4',
  edoNameTable: null, 
  nonoInfo: null, 
  jiRatios: null,
  subsetPattern: [], 
  unisonVoices: 3, 
  detuneCents: 5,
  quantize: true,
  // NEW FX STATE
  adsr: { attack: 0.005, decay: 0.1, sustainLevel: 0.7, release: 0.5 },
  lfo: { rate: 5.0, depth: 10.0 }, // Hz, Cents
  delay: { time: 0.4, feedback: 0.6, wet: 0.3 }
};

// --- WEB AUDIO API SETUP ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Master FX Chain Nodes (NEW)
const masterInputGain = audioCtx.createGain(); // Input to the whole chain (volume control)
const delayNode = audioCtx.createDelay(2.0); // Max 2 seconds delay
const feedbackGain = audioCtx.createGain();
const wetGain = audioCtx.createGain();
const dryGain = audioCtx.createGain();

// Connections: MasterInput -> (Dry Path, Wet Path) -> Destination
masterInputGain.connect(dryGain);
dryGain.connect(audioCtx.destination);

// Wet Path (Delay)
masterInputGain.connect(delayNode);
delayNode.connect(wetGain);
wetGain.connect(audioCtx.destination);

// Feedback Loop
delayNode.connect(feedbackGain);
feedbackGain.connect(delayNode); 

// --- WAV RECORDING STATE AND ELEMENTS ---
let audioProcessor = null;
let recordingBuffers = [];
let isRecording = false;
const NUM_CHANNELS = 1; 

const recordBtn = document.getElementById('recordBtn');
const recordText = document.getElementById('recordText');
const stopRecordBtn = document.getElementById('stopRecordBtn');
const recordingStatus = document.getElementById('recordingStatus');


// Synth Class for Audio Generation (NOW WITH ADSR & LFO POWER)
class Synth {
    constructor(ctx, gainNode, waveType, adsr, unisonVoices, detuneCents, lfoParams) {
        this.ctx = ctx;
        this.masterInput = gainNode;
        this.adsr = adsr; // {attack, decay, sustainLevel, release} in seconds
        this.unisonVoices = Math.max(1, Math.min(16, unisonVoices));
        this.detuneCents = detuneCents;
        this.waveType = waveType;
        this.lfoParams = lfoParams;

        // 1. Voice Gain
        this.gain = ctx.createGain();
        this.gain.gain.setValueAtTime(0.0001, ctx.currentTime);
        this.gain.connect(this.masterInput);

        // 2. LFO for Vibrato (Frequency Modulation)
        this.lfo = ctx.createOscillator();
        this.lfo.type = 'sine';
        this.lfo.frequency.setValueAtTime(lfoParams.rate, ctx.currentTime);
        
        this.lfoGain = ctx.createGain();
        this.lfoGain.gain.setValueAtTime(0, ctx.currentTime); 
        this.lfo.connect(this.lfoGain);
        this.lfo.start(0);

        this.oscillators = [];
        this.initOscillators();
    }
    
    initOscillators() {
        const getPeriodicWave = (type) => {
            const maxHarmonics = 16;
            const real = new Array(maxHarmonics + 1).fill(0);
            real[1] = 1.0; 
            
            if (type === 'piano') {
                real[2] = 0.5; real[3] = 0.4; real[4] = 0.3; real[5] = 0.2; real[6] = 0.1;
            } else if (type === 'guitar') {
                real[2] = 0.1; real[3] = 0.7; real[5] = 0.4; real[7] = 0.2; real[9] = 0.1;
            } else if (type === 'violin') {
                real[2] = 0.8; real[3] = 0.6; real[4] = 0.5; real[5] = 0.4; real[6] = 0.3;
            } else if (type === 'organ') {
                real[2] = 0.6; real[3] = 0.4; real[4] = 0.2; real[5] = 0.1;
            } else if (type === 'electric_guitar') {
                real[3] = 0.8; real[5] = 0.6; real[7] = 0.4; real[9] = 0.2;
            }
            
            const imag = new Array(maxHarmonics + 1).fill(0);
            return this.ctx.createPeriodicWave(real, imag, { disableNormalization: false });
        };
        
        for (let i = 0; i < this.unisonVoices; i++) {
            const osc = this.ctx.createOscillator();
            if (['piano', 'guitar', 'violin', 'organ', 'electric_guitar'].includes(this.waveType)) {
                osc.setPeriodicWave(getPeriodicWave(this.waveType));
            } else {
                osc.type = this.waveType;
            }
            osc.connect(this.gain);
            this.oscillators.push({ osc });
            
            // Connect LFO for Vibrato
            this.lfoGain.connect(osc.frequency);

            osc.start();
        }
    }

    start(baseFrequency) {
        const now = this.ctx.currentTime;
        const targetPeakLevel = 1.0; 
        const targetSustainLevel = this.adsr.sustainLevel * targetPeakLevel;
        const gainLevelPerVoice = targetPeakLevel / this.unisonVoices; 

        this.oscillators.forEach((item, i) => {
            // Calculate detune in cents relative to the center voice
            const detuneSteps = (this.unisonVoices - 1) / 2;
            const detune = (i - detuneSteps) * this.detuneCents;
            item.osc.detune.setValueAtTime(detune, now);
            item.osc.frequency.setValueAtTime(baseFrequency, now);
        });
        
        // 1. Set LFO Depth
        // Modulate frequency by a small Hz amount proportional to the base frequency
        const lfoDepthInHz = baseFrequency * (this.lfoParams.depth / 1200 / 100); 
        this.lfoGain.gain.cancelScheduledValues(now);
        this.lfoGain.gain.setValueAtTime(lfoDepthInHz, now);

        // 2. ADSR Envelope (Gain)
        this.gain.gain.cancelScheduledValues(now);
        this.gain.gain.setValueAtTime(0.0001, now); 

        // Attack phase
        this.gain.gain.linearRampToValueAtTime(gainLevelPerVoice, now + this.adsr.attack);

        // Decay phase
        this.gain.gain.linearRampToValueAtTime(targetSustainLevel * gainLevelPerVoice, now + this.adsr.attack + this.adsr.decay);

        // Sustain phase is handled by holding the note
    }

    release() {
        const now = this.ctx.currentTime;
        
        // 1. Stop LFO modulation for this voice
        this.lfoGain.gain.setValueAtTime(0, now);
        
        // 2. Release Phase
        this.gain.gain.cancelScheduledValues(now);
        this.gain.gain.linearRampToValueAtTime(0, now + this.adsr.release);

        // Stop all oscillators and LFO after the release phase is complete
        this.oscillators.forEach(item => {
            try {
                item.osc.stop(now + this.adsr.release + 0.05);
            } catch (e) {}
        });
        this.lfo.stop(now + this.adsr.release + 0.05); 
    }
}


// --- UI ELEMENTS ---
const canvas = document.getElementById('gridCanvas');
const body = document.body;
const darkModeToggle = document.getElementById('darkModeToggle');
const extremeModeToggle = document.getElementById('extremeModeToggle');
const ctx = canvas.getContext('2d', { alpha:false });
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const keySizeInput = document.getElementById('keySize');
const rootKeyIndexInput = document.getElementById('rootKeyIndex');
const rOffsetInput = document.getElementById('rOffset');
const cOffsetInput = document.getElementById('cOffset');
const hStepsInput = document.getElementById('hSteps');
const vStepsInput = document.getElementById('vSteps');
const dStepsInput = document.getElementById('dSteps');
const tuningType = document.getElementById('tuningType');
const edoStepsInput = document.getElementById('edoSteps');
const nonoParams = document.getElementById('nonoParams');
const nonoSpecInput = document.getElementById('nonoSpec');
const jiParams = document.getElementById('jiParams');
const jiPrimeInput = document.getElementById('jiPrime');
const rootFreqInput = document.getElementById('rootFreq');
const rootNoteNameInput = document.getElementById('rootNoteName');
const scaleSubsetSelect = document.getElementById('scaleSubset');
const applyBtn = document.getElementById('applyBtn');
const tuningText = document.getElementById('tuningText');
const notesLegend = document.getElementById('notesLegend');
const waveSel = document.getElementById('wave');
const volumeSlider = document.getElementById('volumeSlider');
const sustainToggle = document.getElementById('sustainToggle');
const stopAllBtn = document.getElementById('stopAllBtn');
const generateScaleBtn = document.getElementById('generateScaleBtn'); 
const scaleGeneratorModal = document.getElementById('scaleGeneratorModal');
const gen_generator = document.getElementById('gen_generator');
const gen_period = document.getElementById('gen_period');
const gen_udp = document.getElementById('gen_udp');
const gen_cancelBtn = document.getElementById('gen_cancelBtn');
const gen_applyBtn = document.getElementById('gen_applyBtn');
const modeSelector = document.getElementById('modeSelector');
const unisonVoicesInput = document.getElementById('unisonVoices');
const detuneCentsInput = document.getElementById('detuneCents');
const quantizeToggle = document.getElementById('quantizeToggle');

// NEW FX UI ELEMENTS
const attackInput = document.getElementById('attack');
const decayInput = document.getElementById('decay');
const sustainLevelInput = document.getElementById('sustainLevel');
const releaseInput = document.getElementById('release');
const lfoRateInput = document.getElementById('lfoRate');
const lfoDepthInput = document.getElementById('lfoDepth');
const delayTimeInput = document.getElementById('delayTime');
const delayFeedbackInput = document.getElementById('delayFeedback');
const delayWetInput = document.getElementById('delayWet');

// --- AUDIO/SYNTH STATE ---
const activeVoices = new Map(); 
const pointerToIdx = new Map(); 

let baseSubsetPattern = []; 
let currentModeIndex = 0; 
let fullScaleStepsData = []; 

// QWERTY Key to Grid Index Mapping (Z key = 0, Q key = 12)
const keyMap = {
    'z': 0, 's': 1, 'x': 2, 'd': 3, 'c': 4, 'v': 5, 'g': 6, 'b': 7, 'h': 8, 'n': 9, 'j': 10, 'm': 11, // First Row
    'q': 12, '2': 13, 'w': 14, '3': 15, 'e': 16, 'r': 17, '5': 18, 't': 19, '6': 20, 'y': 21, '7': 22, 'u': 23 // Second Row
};
const activeKeys = new Set(); // To track which keyboard keys are currently pressed

// --- INIT/UPDATE FX PARAMETERS ---

function updateMasterFx() {
    delayNode.delayTime.setValueAtTime(parseFloat(delayTimeInput.value), audioCtx.currentTime);
    feedbackGain.gain.setValueAtTime(parseFloat(delayFeedbackInput.value), audioCtx.currentTime);
    wetGain.gain.setValueAtTime(parseFloat(delayWetInput.value), audioCtx.currentTime);
    dryGain.gain.setValueAtTime(1.0 - parseFloat(delayWetInput.value), audioCtx.currentTime); // Ensure dry path is 1-wet
    
    gridState.delay = {
        time: parseFloat(delayTimeInput.value),
        feedback: parseFloat(delayFeedbackInput.value),
        wet: parseFloat(delayWetInput.value)
    };
}

if(volumeSlider) {
  masterInputGain.gain.value = parseFloat(volumeSlider.value);
  volumeSlider.addEventListener('input', (e) => {
    masterInputGain.gain.value = parseFloat(e.target.value);
    // When master gain changes, update all active voice levels to reflect new max level
    activeVoices.forEach(voice => {
        voice.gain.gain.setValueAtTime(voice.gain.gain.value * masterInputGain.gain.value, audioCtx.currentTime);
    });
  });
}

// Initial FX setup
delayTimeInput.addEventListener('input', updateMasterFx);
delayFeedbackInput.addEventListener('input', updateMasterFx);
delayWetInput.addEventListener('input', updateMasterFx);

// --- CORE HELPER FUNCTIONS (WAV Encoding) ---

function mergeBuffers(buffers, totalLength) {
    const result = new Float32Array(totalLength);
    let offset = 0;
    for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
    }
    return result;
}

function bufferToWave(interleavedData, sampleRate) {
    const numChannels = NUM_CHANNELS;
    const bitDepth = 16;
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const totalBytes = interleavedData.length * bytesPerSample;

    const buffer = new ArrayBuffer(44 + totalBytes);
    const view = new DataView(buffer);

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    /* RIFF header */
    writeString(view, 0, 'RIFF'); 
    view.setUint32(4, 36 + totalBytes, true); 
    writeString(view, 8, 'WAVE'); 

    /* FMT sub-chunk */
    writeString(view, 12, 'fmt '); 
    view.setUint32(16, 16, true); 
    view.setUint16(20, 1, true); 
    view.setUint16(22, numChannels, true); 
    view.setUint32(24, sampleRate, true); 
    view.setUint32(28, byteRate, true); 
    view.setUint16(32, blockAlign, true); 
    view.setUint16(34, bitDepth, true); 

    /* DATA sub-chunk */
    writeString(view, 36, 'data'); 
    view.setUint32(40, totalBytes, true); 

    /* Write PCM data (conversion from Float32 to Int16) */
    function floatTo16BitPCM(output, offset, input) {
        for (let i = 0; i < input.length; i++, offset += 2) {
            const s = Math.max(-1, Math.min(1, input[i]));
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    }
    floatTo16BitPCM(view, 44, interleavedData);

    return new Blob([view], { type: 'audio/wav' });
}


// --- CORE HELPER FUNCTIONS (Tuning/Grid) ---

function centsOfRatio(r){ return 1200 * Math.log2(r); }

function parseInterval(input) {
  input = input.trim();
  if(!input) return NaN;

  if (input.includes('\\')) {
    const parts = input.split('\\').map(x => parseFloat(x.trim()));
    if (parts.length === 2 && isFinite(parts[0]) && isFinite(parts[1]) && parts[1] !== 0) {
      return 1200 * (parts[0] / parts[1]); 
    }
    return NaN;
  } 
  
  if (input.includes('/')){
    const [a,b] = input.split('/').map(x=>parseFloat(x.trim()));
    if(isFinite(a) && isFinite(b) && b!==0) return centsOfRatio(a/b);
    return NaN;
  } 
  
  const v = parseFloat(input);
  return isFinite(v) ? v : NaN; 
}

function centsToEDOStepRaw(cents, N) {
  if (N === 0) return 0;
  return Math.round((cents / 1200) * N);
}

function parseUDP(udpStr) {
  const match = udpStr.match(/(\d+)\|(\d+)\((\d+)\)/);
  if (!match) return null;
  return {
    up: parseInt(match[1]),
    down: parseInt(match[2]),
    periods: parseInt(match[3])
  };
}

function mod(a, b) {
  return ((a % b) + b) % b;
}

const canonicalChainOfFifths = ["Dbb", "Abb", "Ebb", "Bbb", "Fb","Cb","Gb","Db","Ab","Eb","Bb","F","C","G","D","A","E","B","F#","C#","G#","D#","A#","E#","B#", "Fx", "Cx"];
const fifthspanMap = {};
canonicalChainOfFifths.forEach((name, i) => { const span = i - canonicalChainOfFifths.indexOf("C"); fifthspanMap[name] = span; });

function generateEDONaming(N){ 
  const kfloat = N * Math.log2(3/2); const k = Math.round(kfloat); const wholeTone = (2 * k) % N; const chromaticRaw = (7 * k) - (4 * N); const chromatic = ((chromaticRaw % N) + N) % N; const diatonic = ((wholeTone - chromatic) % N + N) % N;
  const fifthOffsets = { 'C':0, 'G':1, 'D':2, 'A':3, 'E':4, 'B':5, 'F':-1 }; const letterSteps = {};
  for(const [L, offs] of Object.entries(fifthOffsets)){ let pos = (offs * k) % N; pos = (pos + N) % N; letterSteps[L] = pos; }
  function canonicalNameToStep(name){ const letter = name[0]; const rest = name.slice(1); let base = letterSteps[letter] ?? 0; for(const ch of rest){ if(ch === '#') base = (base + chromatic) % N; else if(ch === 'b') base = (base - chromatic + N) % N; } return (base + N) % N; }
  const stepToCanonicalNames = new Map();
  for(const cname of canonicalChainOfFifths){ const s = canonicalNameToStep(cname); if(!stepToCanonicalNames.has(s)) stepToCanonicalNames.set(s, []); stepToCanonicalNames.get(s).push(cname); }
  const canonicalSteps = Array.from(stepToCanonicalNames.keys());
  const names = Array.from({length:N}, ()=>[]);
  for(const [s,list] of stepToCanonicalNames.entries()) names[s] = [...new Set(list)];
  for(let s=0; s<N; s++){
    if(names[s].length > 0) continue;
    let best = null; let bestAbs = Infinity; let bestSigned = 0; let bestCanonicalStep = null;
    for(const cs of canonicalSteps){
      let signed = ((s - cs + N) % N);
      if(signed > N/2) signed -= N;
      const absd = Math.abs(signed);
      if(absd < bestAbs){ bestAbs = absd; bestSigned = signed; bestCanonicalStep = cs; }
    }
    const baseNames = stepToCanonicalNames.get(bestCanonicalStep) || ['?'];
    const prefList = baseNames.map(bn => {
      if(bestSigned > 0) return '^'.repeat(bestSigned) + bn;
      if(bestSigned < 0) return 'v'.repeat(-bestSigned) + bn;
      return bn;
    });
    names[s] = prefList;
  }
  return { names, info: {k, wholeTone, chromaticRaw, chromatic, diatonic} };
}

function pickSimplestName(list){ 
  if(!Array.isArray(list) || list.length===0) return '?';
  const uniq = Array.from(new Set(list));
  function analyze(n){
    let s = n; let prefixShift = 0;
    while(s[0] === '^' || s[0] === 'v'){ prefixShift += (s[0] === '^' ? 1 : -1); s = s.slice(1); }
    const core = s; const spanFromC = (fifthspanMap[core] ?? 0) + prefixShift; const absSpan = Math.abs(spanFromC);
    const isNatural = /^[A-G]$/.test(core); const sharps = (core.match(/#/g)||[]).length; const flats = (core.match(/b/g)||[]).length;
    const accidentalCount = sharps + flats; const kindScore = isNatural ? 0 : (sharps>0 ? 1 : (flats>0 ? 2 : 3));
    return {orig: n, absSpan, kindScore, accidentalCount, length: n.length};
  }
  const analyzed = uniq.map(s => ({s, a: analyze(s)}));
  analyzed.sort((A,B)=>{
    if(A.a.absSpan !== B.a.absSpan) return A.a.absSpan - B.a.absSpan;  
    if(A.a.kindScore !== B.a.kindScore) return A.a.kindScore - B.a.kindScore;
    if(A.a.accidentalCount !== B.a.accidentalCount) return A.a.accidentalCount - B.a.accidentalCount;
    if(A.a.length !== B.a.length) return A.a.length - B.a.length;
    return A.s.localeCompare(B.s);
  });
  return analyzed[0].s;
}

/**
 * Generates a basic set of JI ratios for a given prime limit. 
 * This is a simplified set for demonstration, focusing on the 5-limit (2, 3, 5).
 */
function generateJIRatios(primeLimit) {
  const ratios = [];
  const P = parseInt(primeLimit);
  
  // Base ratios for 5-limit (2, 3, 5)
  // 1/1, 2/1 (Octave)
  ratios.push({ratio: 1, name: '1/1'});
  
  // 3-limit (P5, P4, M2, m7, etc.)
  if (P >= 3) {
      ratios.push({ratio: 9/8, name: '9/8'});   // M2
      ratios.push({ratio: 4/3, name: '4/3'});   // P4
      ratios.push({ratio: 3/2, name: '3/2'});   // P5
      ratios.push({ratio: 16/9, name: '16/9'}); // m7
  }
  
  // 5-limit (M3, m3, M6, m6, etc.)
  if (P >= 5) {
      ratios.push({ratio: 6/5, name: '6/5'});   // m3
      ratios.push({ratio: 5/4, name: '5/4'});   // M3
      ratios.push({ratio: 8/5, name: '8/5'});   // m6
      ratios.push({ratio: 5/3, name: '5/3'});   // M6
      ratios.push({ratio: 15/8, name: '15/8'}); // M7
  }
  
  // Additional complexity for 7-limit (only adds 7/4 and 7/8 for simplicity)
  if (P >= 7) {
      ratios.push({ratio: 7/4, name: '7/4'});   // Harmonic 7th
  }

  // Normalize to 1/1 to 2/1 and find unique values (using cents for precision)
  const uniqueRatios = new Map();
  const octaveRatio = 2;
  
  for (const item of ratios) {
    let ratio = item.ratio;
    
    // Normalize to the octave (1/1 to < 2/1)
    while (ratio >= octaveRatio) ratio /= octaveRatio;
    
    // Avoid 0/1 ratio
    if (ratio < 1e-6) continue;
    
    // Cents as the key for uniqueness
    const cents = centsOfRatio(ratio); 
    
    if (ratio < 1) { ratio *= octaveRatio; } 

    // Re-calculate cents for the normalized ratio (1 <= ratio < 2)
    const normalizedCents = centsOfRatio(ratio); 
    
    if (!uniqueRatios.has(normalizedCents)) {
        uniqueRatios.set(normalizedCents, { ratio: ratio, name: item.name, cents: normalizedCents });
    }
  }
  
  // Sort by cents value and re-index
  const finalRatios = Array.from(uniqueRatios.values()).sort((a, b) => a.cents - b.cents);
  
  return finalRatios.map((r, i) => ({ ...r, index: i }));
}

// --- MODAL CONTROLS ---

function showModal() { scaleGeneratorModal.style.display = 'flex'; }
function hideModal() { scaleGeneratorModal.style.display = 'none'; }
function showModalMessage(title, message) {
    const existing = document.getElementById('temp-modal');
    if (existing) existing.remove();
    
    const modalHtml = `
      <div id="temp-modal" class="modal-overlay" style="display:flex;">
          <div class="modal-content">
              <h3>${title}</h3><p>${message}</p>
              <div class="modal-controls">
                  <button onclick="document.getElementById('temp-modal').remove()" style="background:#f00; color:white;">Close</button>
              </div>
          </div>
      </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

generateScaleBtn.addEventListener('click', () => {
    if (audioCtx.state !== 'running') { audioCtx.resume().catch(e => console.error("Audio resume failed:", e)); }
    
    if (tuningType.value !== 'edo') {
        showModalMessage('Action Required', 'The scale generator only works when **Tuning Type** is set to **EDO**.');
        return;
    }
    showModal();
});
gen_cancelBtn.addEventListener('click', hideModal);
gen_applyBtn.addEventListener('click', () => {
    generateAndApplyScale(gen_generator.value, gen_period.value, gen_udp.value);
});


// --- SCALE GENERATOR & MODE LOGIC ---

function generateAndApplyScale(generatorStr, periodStr, udpStr) {
    const N = parseInt(edoStepsInput.value);

    if (tuningType.value !== 'edo' || !N || N < 2) {
        showModalMessage('Error', 'Please ensure Tuning Type is EDO and EDO steps (N) is a valid number (> 1).');
        return;
    }

    const generatorCents = parseInterval(generatorStr);
    const periodCents = parseInterval(periodStr);
    const udp = parseUDP(udpStr);

    if (!udp || isNaN(generatorCents) || isNaN(periodCents)) {
        showModalMessage('Error', 'Invalid input for Generator, Period, or UDP format. Please check your values.');
        return;
    }

    const generatorStepRaw = centsToEDOStepRaw(generatorCents, N);
    const periodStepRaw = centsToEDOStepRaw(periodCents, N);

    if (Math.abs(periodStepRaw) < 1) {
        showModalMessage('Error', 'The Period interval cannot quantize to zero EDO steps. It must represent at least one full step.');
        return;
    }

    const pitchesEDOSteps = new Set();
    
    for (let p = 0; p < udp.periods; p++) {
        const periodOffset = p * periodStepRaw; 
        for (let i = -udp.down; i <= udp.up; i++) {
            let step = (i * generatorStepRaw) + periodOffset; 
            step = mod(step, N); 
            pitchesEDOSteps.add(step);
        }
    }
    
    // The base pattern MUST be sorted for interval calculation and UI
    const finalScale = Array.from(pitchesEDOSteps).sort((a, b) => a - b);
    
    if (finalScale.length < 2) {
        showModalMessage('Error', 'The generated scale has fewer than 2 unique steps. Try different parameters.');
        return;
    }

    // Set the BASE pattern and reset the mode
    baseSubsetPattern = finalScale;
    currentModeIndex = 0;
    
    applyBaseSubsetToGrid(); // Applies mode 0 and updates UI
    hideModal();
}

/**
 * Calculates the current mode pattern by rotating the intervals of the base scale.
 * The result is an UNSORTED array of EDO steps in sequential order.
 */
function calculateModePattern(basePattern, startIndex) {
    if (basePattern.length === 0) return [];
    
    const N = fullScaleStepsData.length;
    const size = basePattern.length;
    
    // 1. Calculate intervals (size intervals including the one closing the octave/period)
    const intervals = [];
    // N is the total number of steps in the full reference system
    const periodSteps = N; 
    
    for (let i = 0; i < size; i++) {
        const currentStep = basePattern[i];
        
        let nextStepInFull;
        if (i === size - 1) {
            // Interval to the "octave"
            nextStepInFull = periodSteps; 
        } else {
            nextStepInFull = basePattern[i + 1];
        }
        
        let interval = nextStepInFull - currentStep;
        
        if (i === size - 1 && currentStep !== 0) {
            interval = periodSteps - currentStep; 
        } else if (interval < 0) {
             interval += periodSteps; 
        }
        intervals.push(interval);
    }
    
    // 2. Rotate intervals based on the start index
    const rotationAmount = startIndex % size;
    const rotatedIntervals = intervals.slice(rotationAmount).concat(intervals.slice(0, rotationAmount));
    
    // 3. Reconstruct the steps starting from step 0 (which is always 0)
    const modePattern = [0];
    let currentStep = 0;
    
    // We only need to generate size - 1 steps (steps 1 through size-1)
    for (let i = 0; i < size - 1; i++) { 
        currentStep = (currentStep + rotatedIntervals[i]);
        modePattern.push(currentStep);
    }

    return modePattern; 
}

/**
 * Applies the base pattern and current mode index to the grid state, 
 * then updates all related UI elements.
 */
function applyBaseSubsetToGrid() {
    const N = fullScaleStepsData.length;
    // If the base pattern is empty, default to full scale (0..N-1)
    if (baseSubsetPattern.length === 0 && N > 0) {
        baseSubsetPattern = Array.from({length: N}, (_, i) => i);
    }
    
    // 1. Calculate the new mode pattern 
    let finalPattern = baseSubsetPattern;
    if (gridState.quantize && baseSubsetPattern.length > 0) {
        finalPattern = calculateModePattern(baseSubsetPattern, currentModeIndex);
    }
    
    // 2. Apply the calculated pattern to the grid state
    gridState.subsetPattern = finalPattern;
    
    // 3. Update the UI controls
    populateModeSelector(baseSubsetPattern);
    applySubsetPatternToUI(baseSubsetPattern); 
    
    // RENDER
    updateLegend();
    resizeCanvas();
    renderGrid();
}

// --- STATE MANAGEMENT AND UI UPDATES ---

function generateFullScaleSteps(tuning, edoNameTable, jiRatios) {
  let steps = []; let N = 0; 
  if (tuning.type === 'edo') {
    N = tuning.edo;
    for (let i = 0; i < N; i++) {
      steps.push({ index: i, name: pickSimplestName(edoNameTable[i] || [`${i}`]) });
    }
  } else if (tuning.type === 'nonoctave') {
    N = tuning.steps;
    for (let i = 0; i < N; i++) {
        const cents = tuning.nonoInfo.centsPerStep * i;
        steps.push({ index: i, name: `Step ${i} (${cents.toFixed(2)}¢)` });
    }
  } else if (tuning.type === 'ji') {
    N = jiRatios.length;
    for (let i = 0; i < N; i++) {
        const ratio = jiRatios[i];
        steps.push({ index: i, name: `${ratio.name} (${ratio.cents.toFixed(2)}¢)` });
    }
  }
  return { steps, N };
}

function populateScaleSubsetSelect(fullSteps) {
  const select = document.getElementById('scaleSubset');
  select.innerHTML = ''; 
  if (fullSteps.length === 0) {
    select.innerHTML = '<option disabled>No steps available</option>';
    return;
  }
  
  const labelDiv = select.parentNode.querySelector('.small');
  if (labelDiv) {
      labelDiv.previousSibling.textContent = `Scale Subset (Select Notes) [${fullSteps.length} Items]`;
  }
  
  for (const step of fullSteps) {
    const option = document.createElement('option');
    option.value = step.index; 
    option.textContent = `[${step.index}] ${step.name}`; 
    select.appendChild(option);
  }
}

function populateModeSelector(subsetSteps) {
    modeSelector.innerHTML = '';
    
    if (subsetSteps.length === 0) {
        modeSelector.innerHTML = '<option disabled>No steps</option>';
        return;
    }

    const fullStepsDataMap = new Map(fullScaleStepsData.map(s => [s.index, s.name]));

    subsetSteps.forEach((step, index) => {
        const name = fullStepsDataMap.get(step) || `Step ${step}`;
        const option = document.createElement('option');
        option.value = index; 
        option.textContent = `${name}`;
        modeSelector.appendChild(option);
    });
    
    modeSelector.value = currentModeIndex;
}

function applySubsetPatternToUI(pattern) {
    for (const option of scaleSubsetSelect.options) { option.selected = false; }
    const patternSet = new Set(pattern.map(String)); 
    for (const option of scaleSubsetSelect.options) {
        if (patternSet.has(option.value)) {
            option.selected = true;
        }
    }
}

function getSelectedSubset() {
    const selections = [];
    for (const option of scaleSubsetSelect.options) {
      if (option.selected) {
        selections.push(parseInt(option.value, 10));
      }
    }
    const finalPattern = [...new Set([0, ...selections])].sort((a, b) => a - b);
    return finalPattern;
}

function updateLegend(){
  const t = gridState.tuning;
  const subsetSize = gridState.subsetPattern.length;
  const mapType = gridState.quantize ? 'Quantized' : 'Raw';
  let txt = `Grid: ${gridState.rows}×${gridState.cols} • Key size: ${gridState.keySize}px • Root: ${gridState.rootName} @ ${gridState.rootFreq.toFixed(4)} Hz. `;
  let tuningSummary = '—';
  
  if(t.type === 'edo') {
      tuningSummary = `${t.edo}-EDO`;
      txt += `${tuningSummary}. Scale Size: ${subsetSize}.`;
  } else if (t.type === 'nonoctave') {
      tuningSummary = `${t.steps}ed${t.cents} (${t.nonoInfo.centsPerStep.toFixed(2)}¢/step)`;
      txt += `${tuningSummary}. Scale Size: ${subsetSize}.`;
  } else if (t.type === 'ji') {
      tuningSummary = `${t.primeLimit}-Limit JI (${t.jiRatios.length} steps)`;
      txt += `${tuningSummary}. Scale Size: ${subsetSize}.`;
  }
  
  if (subsetSize > 0) {
     txt += ` Mode: ${modeSelector.options[currentModeIndex]?.textContent || 'Ionian'}.`;
  }
  
  txt += ` Mapping (${mapType}): H=${gridState.hSteps}, V=${gridState.vSteps}, D=${gridState.dSteps}. Offset: R=${gridState.rOffset}, C=${gridState.cOffset}. Root Key=${gridState.rootKeyIndex}.`;
  txt += ` Synth: ${gridState.unisonVoices}x Voices, ${gridState.detuneCents}¢ Detune.`;
  txt += ` ADSR: A${gridState.adsr.attack} D${gridState.adsr.decay} S${gridState.adsr.sustainLevel} R${gridState.adsr.release}.`;
  txt += ` LFO: ${gridState.lfo.rate}Hz @ ${gridState.lfo.depth}¢.`;
  txt += ` Delay: ${gridState.delay.time}s @ ${gridState.delay.feedback} FB / ${gridState.delay.wet} Wet.`;

  tuningText.textContent = `Tuning: ${tuningSummary}`;
  notesLegend.textContent = txt;
}

function buildStateFromUI(){
  const rows = Math.max(1, parseInt(rowsInput.value) || 6);
  const cols = Math.max(1, parseInt(colsInput.value) || 12);
  const keySize = Math.max(8, parseInt(keySizeInput.value) || 64);
  const rootFreq = Math.max(1, parseFloat(rootFreqInput.value) || 261.6256);
  const rootName = rootNoteNameInput.value || 'root';
  const type = tuningType.value;
  
  const maxKeyIndex = rows * cols;
  const rootKeyIndex = Math.max(1, Math.min(maxKeyIndex, parseInt(rootKeyIndexInput.value) || 1));
  const rOffset = parseInt(rOffsetInput.value) || 0;
  const cOffset = parseInt(cOffsetInput.value) || 0;
  const hSteps = parseInt(hStepsInput.value) || 1;
  const vSteps = parseInt(vStepsInput.value) || 7;
  const dSteps = parseInt(dStepsInput.value) || 8;
  
  const unisonVoices = Math.max(1, Math.min(16, parseInt(unisonVoicesInput.value) || 3));
  const detuneCents = parseFloat(detuneCentsInput.value) || 5;
  const quantize = quantizeToggle.checked;

  // NEW FX State Update
  const adsr = {
      attack: Math.max(0.001, parseFloat(attackInput.value) || 0.005),
      decay: Math.max(0.001, parseFloat(decayInput.value) || 0.1),
      sustainLevel: Math.max(0.0, Math.min(1.0, parseFloat(sustainLevelInput.value) || 0.7)),
      release: Math.max(0.005, parseFloat(releaseInput.value) || 0.5)
  };
  const lfo = {
      rate: Math.max(0.01, parseFloat(lfoRateInput.value) || 5.0),
      depth: Math.max(0.0, parseFloat(lfoDepthInput.value) || 10.0)
  };

  gridState.rows = rows; gridState.cols = cols; gridState.keySize = keySize;
  gridState.rootFreq = rootFreq; gridState.rootName = rootName;
  gridState.rootKeyIndex = rootKeyIndex;
  gridState.rOffset = rOffset; gridState.cOffset = cOffset;
  gridState.hSteps = hSteps; gridState.vSteps = vSteps; gridState.dSteps = dSteps;
  gridState.unisonVoices = unisonVoices; gridState.detuneCents = detuneCents;
  gridState.quantize = quantize;
  gridState.adsr = adsr;
  gridState.lfo = lfo;

  let totalSteps = 0; 
  let tuningChanged = false;

  if(type === 'edo'){
    const N = Math.max(2, parseInt(edoStepsInput.value) || 12);
    tuningChanged = gridState.tuning.edo !== N || gridState.tuning.type !== 'edo';
    gridState.tuning = { type:'edo', edo: N };
    gridState.edoNameTable = generateEDONaming(N).names;
    gridState.nonoInfo = null; gridState.jiRatios = null;
  } else if (type === 'nonoctave') {
    const spec = nonoSpecInput.value.trim();
    const match = spec.match(/(\d+)ed(\d+)/);
    let steps = 12;
    let cents = 1200;
    if (match) {
        steps = parseInt(match[1]);
        cents = parseFloat(match[2]);
    }
    steps = Math.max(2, steps || 12);
    cents = Math.max(1, cents || 1200);

    const nonoInfo = {
        stepRatio: Math.pow(2, (cents / 1200) / steps),
        centsPerStep: cents / steps,
        totalSteps: steps 
    };
    tuningChanged = gridState.tuning.steps !== steps || gridState.tuning.cents !== cents || gridState.tuning.type !== 'nonoctave';
    gridState.tuning = { type: 'nonoctave', steps: steps, cents: cents, nonoInfo: nonoInfo };
    gridState.nonoInfo = nonoInfo;
    gridState.edoNameTable = null; gridState.jiRatios = null;
  } else if (type === 'ji') {
    const P = Math.max(3, parseInt(jiPrimeInput.value) || 5);
    const jiRatios = generateJIRatios(P);
    tuningChanged = gridState.tuning.primeLimit !== P || gridState.tuning.type !== 'ji';
    gridState.tuning = { type: 'ji', primeLimit: P, jiRatios: jiRatios };
    gridState.jiRatios = jiRatios;
    gridState.edoNameTable = null; gridState.nonoInfo = null;
  }
  
  const fullStepsResult = generateFullScaleSteps(
    gridState.tuning, 
    gridState.edoNameTable, 
    gridState.jiRatios
  );
  fullScaleStepsData = fullStepsResult.steps;
  totalSteps = fullStepsResult.N;

  // Only repopulate scale selector and reset pattern if the tuning system itself changed
  if (tuningChanged || totalSteps !== scaleSubsetSelect.options.length) {
      populateScaleSubsetSelect(fullScaleStepsData);
      // Default to full scale selection visually
      for (const option of scaleSubsetSelect.options) { option.selected = true; }
      baseSubsetPattern = Array.from({length: totalSteps}, (_, i) => i);
      currentModeIndex = 0;
  } else {
      // Update base pattern from manual selection if tuning didn't change
      const manuallySelectedSubset = getSelectedSubset();
      if (JSON.stringify(manuallySelectedSubset) !== JSON.stringify(baseSubsetPattern)) {
          baseSubsetPattern = manuallySelectedSubset;
          currentModeIndex = 0; // Reset mode when base scale changes
      }
  }

  // Apply the currently active mode to the grid state
  applyBaseSubsetToGrid();
  updateMasterFx();

  return true;
}

/**
 * Calculates the scale step and octave for a given key index based on the 2D grid mapping.
 * This is the ADVANCED MAPPING LOGIC.
 */
function calculateGridMapping(idx) {
    const { rows, cols, rootKeyIndex, rOffset, cOffset, hSteps, vSteps, dSteps, subsetPattern, quantize } = gridState;
    
    // Fallback if no scale is selected
    if (subsetPattern.length === 0) return { step: 0, octaveShift: 0 };
    
    const totalScaleSteps = fullScaleStepsData.length;
    
    // 1. Calculate relative position from the Root Key
    const rootIdx0 = rootKeyIndex - 1; 
    
    if (idx < 0 || idx >= rows * cols) {
        return { step: 0, octaveShift: 0 };
    }
    
    const r = Math.floor(idx / cols);
    const c = idx % cols;
    const r_root = Math.floor(rootIdx0 / cols);
    const c_root = rootIdx0 % cols;
    
    const r_diff = r - r_root;
    const c_diff = c - c_root;
    
    // 2. Calculate total steps shift based on the isomorphic mapping matrix
    // Pitch is determined by a linear combination: P = C * H + R * V + (C+R) * D + Offset
    const totalStepShift = (
        (c_diff * hSteps) + 
        (r_diff * vSteps) + 
        // This makes the mapping extremely complex/non-orthogonal
        ((r_diff + c_diff) * dSteps) + 
        rOffset + cOffset 
    );
    
    let baseStep;
    let periodSize;
    let totalShift;

    if (quantize) {
        // Quantized mode: map shift to the subset scale degrees (0 to subsetLength-1)
        const subsetLength = subsetPattern.length;
        periodSize = subsetLength;
        
        // Octave shift relative to the root key of the current mode
        const octaveShift = Math.floor(totalStepShift / periodSize);
        
        // Index within the current scale subset (always positive)
        const subsetIndex = mod(totalStepShift, periodSize);
        
        // The step is the actual step index in the *full* system (0 to totalScaleSteps-1)
        baseStep = subsetPattern[subsetIndex]; 
        totalShift = baseStep + (octaveShift * totalScaleSteps);
    } else {
        // Raw mode: map shift directly to the full steps system (0 to totalScaleSteps-1)
        periodSize = totalScaleSteps;
        
        // Total shift relative to the root of the full system (C0/1/etc.)
        totalShift = totalStepShift;
    }
    
    const finalOctaveShift = Math.floor(totalShift / totalScaleSteps);
    const finalStep = mod(totalShift, totalScaleSteps);

    return { step: finalStep, octaveShift: finalOctaveShift, isQuantized: quantize };
}


function frequencyForIndex(idx){
  const t = gridState.tuning; 
  const root = gridState.rootFreq;
  const { step, octaveShift } = calculateGridMapping(idx);

  if(t.type === 'edo'){
    const N = t.edo;
    // Effective EDO step from 0 of the full EDO system
    const effectiveStep = step + (octaveShift * N);
    return root * Math.pow(2, effectiveStep / N);
  }
  
  if (t.type === 'nonoctave'){
    const N = t.steps;
    const { stepRatio } = t.nonoInfo;
    
    // Effective Nonoctave step from 0 of the full Nonoctave EDO
    const effectiveStep = step + (octaveShift * N); 
    
    return root * Math.pow(stepRatio, effectiveStep);
  }
  
  if (t.type === 'ji'){
    const fullRatios = t.jiRatios;
    // JI is weird because the "steps" are pre-calculated ratios, not equally spaced
    if (step < 0 || step >= fullRatios.length) return root; 
    
    const baseRatio = fullRatios[step].ratio;
    
    // Total octave shift (2^octaveShift)
    const octaveMultiplier = Math.pow(2, octaveShift); 
    
    return root * baseRatio * octaveMultiplier;
  }
  
  return root;
}

function nameForIndex(idx){
  const t = gridState.tuning;
  const { step, octaveShift, isQuantized } = calculateGridMapping(idx);

  // 1. Calculate Octave Shift
  const rootOctaveMatch = gridState.rootName.match(/\d/);
  const rootOctave = rootOctaveMatch ? parseInt(rootOctaveMatch[0], 10) : 4; 
  const effectiveOctave = rootOctave + octaveShift;
  
  let baseName = '';
  
  // Find the name of the step in the full steps data
  const stepData = fullScaleStepsData.find(s => s.index === step);
  baseName = stepData ? stepData.name : `Step ${step}`;
  
  if (t.type === 'edo') {
      // Clean up EDO generated name and append octave
      baseName = baseName.replace(/\d/g, ''); 
      return `${baseName}${effectiveOctave}`;
  }
  
  // For Nonoctave and JI, just show the interval/step name plus octave information if possible
  return `${baseName} (Oct+${octaveShift})`;
}

// --- MODE SELECTOR HANDLER ---
modeSelector.addEventListener('change', () => {
    currentModeIndex = parseInt(modeSelector.value, 10);
    applyBaseSubsetToGrid();
});

quantizeToggle.addEventListener('change', () => {
    applyBaseSubsetToGrid();
});

// --- CANVAS DRAWING & INTERACTION ---

function resizeCanvas(){ 
  const ks = gridState.keySize; 
  const width = gridState.cols * ks; 
  const height = gridState.rows * ks; 
  
  canvas.width = width; 
  canvas.height = height; 
}

function renderGrid(){ 
  const ks = gridState.keySize, rows = gridState.rows, cols = gridState.cols; 
  const keyColor = getComputedStyle(document.documentElement).getPropertyValue('--key-color').trim();
  const keyInactive = getComputedStyle(document.documentElement).getPropertyValue('--key-inactive').trim();
  const keyTextColor = getComputedStyle(document.documentElement).getPropertyValue('--key-text-color').trim();
  
  ctx.fillStyle=keyColor; ctx.fillRect(0,0,canvas.width,canvas.height); 
  
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1; 
  ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif'; 
  ctx.textAlign='center'; ctx.textBaseline='middle'; 
  
  const rootIdx0 = gridState.rootKeyIndex - 1; 

  for(let r=0;r<rows;r++){ 
    for(let c=0;c<cols;c++){ 
      const x=c*ks, y=r*ks; 
      const idx=r*cols+c; 
      
      const isRoot = idx === rootIdx0;

      let bgColor = keyInactive;
      if (activeVoices.has(idx)) {
        bgColor = getComputedStyle(document.documentElement).getPropertyValue('--key-active').trim();
      } else if (isRoot) {
        bgColor = 'rgba(255, 100, 100, 0.3)'; 
      }
      
      ctx.fillStyle = bgColor; 
      
      ctx.fillRect(x,y,ks,ks); 
      ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1); 
      
      let label = nameForIndex(idx); 
      ctx.fillStyle=keyTextColor; 
      let disp=String(label); if(disp.length>14) disp = disp.slice(0,12)+'…';
      ctx.fillText(disp, x+ks/2, y+ks/2); 
    } 
  }
}

function drawKeyActive(idx, isActive) { 
  const ks = gridState.keySize; 
  const cols = gridState.cols;
  const rows = gridState.rows;
  const rootIdx0 = gridState.rootKeyIndex - 1; 
  
  const c = idx % cols; 
  const r = Math.floor(idx / cols); 

  if (r < 0 || r >= rows || c < 0 || c >= cols) return;
  
  const x = c * ks; const y = r * ks; 
  const isRoot = idx === rootIdx0;
  
  const keyActive = getComputedStyle(document.documentElement).getPropertyValue('--key-active').trim();
  const keyInactive = getComputedStyle(document.documentElement).getPropertyValue('--key-inactive').trim();
  const keyTextColor = getComputedStyle(document.documentElement).getPropertyValue('--key-text-color').trim();

  let bgColor = keyInactive;
  if (isActive) {
      bgColor = keyActive;
  } else if (isRoot) {
      bgColor = 'rgba(255, 100, 100, 0.3)'; 
  }

  ctx.fillStyle = bgColor; 
  
  ctx.fillRect(x,y,ks,ks); 
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1; ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1); 
  let label = nameForIndex(idx); 
  ctx.fillStyle=keyTextColor; 
  let disp=String(label); if(disp.length>14) disp = disp.slice(0,12)+'…';
  ctx.fillText(disp, x+ks/2, y+ks/2);
}

function noteOn(idx){ 
  if(activeVoices.has(idx)) return; 
  
  if (audioCtx.state === 'suspended') { audioCtx.resume(); } 
  
  const freq = frequencyForIndex(idx); 
  const wave = waveSel.value; 
  const unison = gridState.unisonVoices;
  const detune = gridState.detuneCents;
  const adsr = gridState.adsr;
  const lfo = gridState.lfo;
  
  // Pass all required parameters to the Synth constructor
  const voice = new Synth(audioCtx, masterInputGain, wave, adsr, unison, detune, lfo); 
  activeVoices.set(idx, voice); 
  voice.start(freq); 
  drawKeyActive(idx, true);
}

function noteOff(idx){ 
  const voice = activeVoices.get(idx); if(!voice) return; 
  
  if (sustainToggle.checked && !activeKeys.has(idx)) { 
    // If sustain is checked and this is a pointer release, do nothing 
    // UNLESS the pointer release corresponds to a key that was also pressed by keyboard,
    // which is why we track activeKeys separately. Since we can't reliably track 
    // pointer vs key press for the same index, we rely on ADSR for release.
  } else { 
    voice.release(); 
    activeVoices.delete(idx); 
    drawKeyActive(idx, false); 
  }
}

function stopAllVoices() { 
    if (audioCtx.state !== 'running') { audioCtx.resume(); }
    
    activeVoices.forEach((voice, idx) => { voice.release(); drawKeyActive(idx, false); }); 
    activeVoices.clear();
    activeKeys.clear(); // Also clear keyboard active keys
}

function canvasPosToIndex(e) { 
  const rect = canvas.getBoundingClientRect(); 
  // Handle both mouse and touch events
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  
  const scaleX = canvas.width / rect.width; 
  const scaleY = canvas.height / rect.height; 
  const x = (clientX - rect.left) * scaleX; 
  const y = (clientY - rect.top) * scaleY; 
  const col = Math.floor(x / gridState.keySize); 
  const row = Math.floor(y / gridState.keySize); 
  if (row >= 0 && row < gridState.rows && col >= 0 && col < gridState.cols) { return row * gridState.cols + col; } 
  return -1;
}

function pointerdown(e) { 
  e.preventDefault(); 
  e.stopPropagation(); 

  if (audioCtx.state !== 'running') { audioCtx.resume().catch(e => console.error("Audio resume failed:", e)); }
  
  const pointerId = e.pointerId !== undefined ? e.pointerId : 0;

  const idx = canvasPosToIndex(e); 
  if(idx !== -1) { 
    try { canvas.setPointerCapture(pointerId); } catch(_) {}
    
    // Tap to re-trigger logic 
    if (activeVoices.has(idx)) {
        // Stop current voice immediately and restart
        activeVoices.get(idx).release();
        activeVoices.delete(idx); 
        drawKeyActive(idx, false); // Instant visual update before re-trigger
    }
    
    pointerToIdx.set(pointerId, idx); noteOn(idx); 
  }
}

function pointermove(e) {
  const pointerId = e.pointerId !== undefined ? e.pointerId : 0;
  if (!pointerToIdx.has(pointerId)) return;
  
  e.preventDefault();
  e.stopPropagation(); 

  const prevIdx = pointerToIdx.get(pointerId);
  const currentIdx = canvasPosToIndex(e);

  if (currentIdx === prevIdx) return; 

  // Manual release if moving off key
  if (prevIdx !== -1) {
    activeVoices.get(prevIdx)?.release();
    activeVoices.delete(prevIdx);
    drawKeyActive(prevIdx, false);
  }
  
  if (currentIdx !== -1) {
    noteOn(currentIdx);
    pointerToIdx.set(pointerId, currentIdx);
  } else {
    // Pointer moved off canvas/invalid area
    pointerToIdx.set(pointerId, -1);
  }
}


function pointerup(e) { 
  e.preventDefault(); 
  e.stopPropagation(); 
  const pointerId = e.pointerId !== undefined ? e.pointerId : 0;
  const idx = pointerToIdx.get(pointerId); 
  
  if (typeof idx === 'number' && idx !== undefined && idx !== -1) { 
    // Release the voice regardless of sustain state for touch/mouse
    // We want the ADSR Release phase to handle the decay.
    noteOff(idx);
  }
  pointerToIdx.delete(pointerId); 
  try { canvas.releasePointerCapture(pointerId); } catch(_) {}
}

// Use pointer events for unified mouse/touch handling
canvas.addEventListener('pointerdown', pointerdown);
canvas.addEventListener('pointermove', pointermove); 
canvas.addEventListener('pointerup', pointerup);
canvas.addEventListener('pointercancel', pointerup);
canvas.addEventListener('pointerleave', (e) => { // Handle pointer leaving the canvas area
    const pointerId = e.pointerId !== undefined ? e.pointerId : 0;
    if (pointerToIdx.has(pointerId)) {
        // Manually trigger release logic
        const idx = pointerToIdx.get(pointerId); 
        noteOff(idx); 
        pointerToIdx.delete(pointerId);
    }
});

// --- KEYBOARD INPUT HANDLER (NEW) ---

document.addEventListener('keydown', (e) => {
    // Prevent default browser actions for common keys
    if (e.key === ' ' || e.key === 'Tab') { e.preventDefault(); }
    
    const key = e.key.toLowerCase();
    const idx = keyMap[key];
    
    if (idx !== undefined) {
        // Prevent key repeat
        if (activeKeys.has(key)) return;
        
        const maxKeys = gridState.rows * gridState.cols;
        if (idx < maxKeys) {
            noteOn(idx);
            activeKeys.add(key);
        }
    }
});

document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    const idx = keyMap[key];
    
    if (idx !== undefined) {
        if (activeKeys.has(key)) {
            noteOff(idx);
            activeKeys.delete(key);
        }
    }
});

// --- WAV AUDIO RECORDING FUNCTIONS (UNCHANGED) ---

function startRecording() {
    if (isRecording) return;
    
    if (audioCtx.state !== 'running') {
        audioCtx.resume().catch(e => console.error("Audio resume failed:", e));
    }
    
    recordingBuffers = [];
    
    const bufferSize = 4096;
    // Use ScriptProcessorNode only if AudioWorklet is not available
    audioProcessor = audioCtx.createScriptProcessor(bufferSize, NUM_CHANNELS, NUM_CHANNELS);

    audioProcessor.onaudioprocess = (e) => {
        if (!isRecording) return;
        // Get the first channel (mono)
        const channelData = e.inputBuffer.getChannelData(0);
        recordingBuffers.push(new Float32Array(channelData));
    };

    // Connect the master output (which is before delay) to the processor
    // NOTE: This will only record the *pre-FX* signal. To record post-FX, 
    // we must connect the final destination output. For simplicity, we record the dry signal path.
    // To record the full mix, we connect the final context destination to the processor.
    // Since we can't reliably capture the destination, we connect masterInputGain.
    // To capture the whole mix including delay, we need a tap off the main output.
    // Let's connect masterInputGain to the processor for now, but inform the user.
    // To capture FX, we'll connect the final output (wetGain or dryGain) to the processor input.
    // For simplicity and to capture the mixed signal, we'll try tapping the dryGain for now.
    
    // Capture the signal *after* the dry/wet split (so it includes the delay effect output)
    // Create a mixing node for the final output path.
    const finalMixGain = audioCtx.createGain();
    dryGain.disconnect(); 
    wetGain.disconnect();
    dryGain.connect(finalMixGain);
    wetGain.connect(finalMixGain);
    finalMixGain.connect(audioCtx.destination); // Final output to speakers
    
    finalMixGain.connect(audioProcessor); // Connect to recorder input
    audioProcessor.connect(audioCtx.destination); // Connect recorder output back to speakers (required)


    isRecording = true;
    recordBtn.disabled = true;
    stopRecordBtn.disabled = false;
    recordText.innerHTML = '&#9679; RECORDING'; 
    recordingStatus.textContent = 'Recording in progress (includes Delay FX)...';
    recordingStatus.classList.add('recording-status');
}

function stopRecording() {
    if (!isRecording) return;
    
    // The previous connection setup needs to be reversed (This is complex in a single file).
    // The simplest way to stop the recording is just to disconnect the processor.

    audioProcessor.disconnect(audioCtx.destination);
    
    // We do not need to disconnect the finalMixGain from the destination as it's the playback path.
    // finalMixGain.disconnect(audioProcessor); // Disconnect the recorder tap
    
    audioProcessor = null;
    isRecording = false;

    recordingStatus.textContent = 'Compiling WAV file...';
    recordingStatus.classList.remove('recording-status');
    
    const totalLength = recordingBuffers.reduce((sum, buffer) => sum + buffer.length, 0);
    
    const audioData = mergeBuffers(recordingBuffers, totalLength);
    
    const wavBlob = bufferToWave(audioData, audioCtx.sampleRate);
    
    const url = URL.createObjectURL(wavBlob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    a.download = `synth_recording_extreme_${timestamp}.wav`;
    
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    document.body.removeChild(a);

    recordBtn.disabled = false;
    stopRecordBtn.disabled = true;
    recordText.textContent = 'Record';
    recordingStatus.textContent = 'Recording complete.';
    
    console.log("Recording successfully exported as WAV.");
}

// Attach recording event listeners
recordBtn.addEventListener('click', startRecording);
stopRecordBtn.addEventListener('click', stopRecording);


// --- DARK / EXTREME MODE LOGIC ---

function applyTheme(isDark, isExtreme) {
    body.classList.remove('dark-mode', 'extreme-mode');
    
    if (isExtreme) {
        body.classList.add('extreme-mode');
        extremeModeToggle.textContent = 'EXIT EXTREME MODE';
        localStorage.setItem('theme', 'extreme');
        localStorage.removeItem('isDark');
    } else if (isDark) {
        body.classList.add('dark-mode');
        darkModeToggle.textContent = 'Disable Dark Mode';
        extremeModeToggle.textContent = 'EXTREME MODE';
        localStorage.setItem('theme', 'dark');
    } else {
        darkModeToggle.textContent = 'Enable Dark Mode';
        extremeModeToggle.textContent = 'EXTREME MODE';
        localStorage.setItem('theme', 'light');
    }
    renderGrid();
}

function toggleDarkMode() {
    const isDark = !body.classList.contains('dark-mode');
    applyTheme(isDark, false);
}

function toggleExtremeMode() {
    const isExtreme = !body.classList.contains('extreme-mode');
    applyTheme(false, isExtreme); 
}

darkModeToggle.addEventListener('click', toggleDarkMode);
extremeModeToggle.addEventListener('click', toggleExtremeMode);


// --- UI TOGGLE AND EVENT LISTENERS ---

tuningType.addEventListener('change', (e) => {
    edoParams.style.display = 'none';
    nonoParams.style.display = 'none';
    jiParams.style.display = 'none';
    generateScaleBtn.style.display = 'none';

    switch(e.target.value) {
        case 'edo':
            edoParams.style.display = 'flex';
            generateScaleBtn.style.display = 'block';
            break;
        case 'nonoctave':
            nonoParams.style.display = 'flex';
            break;
        case 'ji':
            jiParams.style.display = 'flex';
            break;
    }
});

applyBtn.addEventListener('click', () => { 
    if (audioCtx.state !== 'running') { audioCtx.resume(); } 
    buildStateFromUI(); 
});

stopAllBtn.addEventListener('click', stopAllVoices);


// --- INIT ---

window.addEventListener('resize', () => { resizeCanvas(); renderGrid(); });

document.addEventListener('DOMContentLoaded', () => {
    // 1. Load theme preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'extreme') {
        applyTheme(false, true);
    } else if (savedTheme === 'dark') {
        applyTheme(true, false);
    } else {
        applyTheme(false, false); 
    }
    
    // 2. Trigger the tuning type change handler to set initial UI visibility
    tuningType.dispatchEvent(new Event('change'));
    
    // 3. Build initial state and render
    buildStateFromUI();
});
</script>
</body>
</html>

