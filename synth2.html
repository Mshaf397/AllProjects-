<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grid Web Synth — New Timbres</title>
<style>
  :root {
  --pad: 10px;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}

body {
  margin: 0;
  padding: var(--pad);
  background: #1E90FF; /* DodgerBlue background */
  color: #f12345;
}

header {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-bottom: 8px;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: end;
  background: #323ddd;
  padding: 12px;
  border-radius: 8px;
  box-shadow: 0 1px 0 rgba(0,0,0,0.2);
}

label {
  font-size: 13px;
  display: flex;
  flex-direction: column;
  min-width: 120px;
}

/* Specific styling for the range input to ensure it fits nicely */
input[type="range"] {
  height: 30px;
  cursor: grab;
}

input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin-top: 5px;
}

input[type="number"],
input[type="text"],
select {
  padding: 6px;
  font-size: 14px;
}

button {
  padding: 8px 12px;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  background: #12e34b;
  color: #323ddd;
  border: none;
  font-weight: bold;
  transition: background 0.1s;
}
button:hover {
  background: #0fbc3c;
}


#gridWrap {
  margin-top: 12px;
  border-radius: 8px;
  overflow: auto;
  background: #1E26FF; /* Match body background */
  padding: 8px;
  max-height: 64vh;
}

canvas {
  display: block;
  background: #228222; /* ForestGreen keys */
  border-radius: 4px;
}

.small {
  font-size: 12px;
  color: #12e34b;
}

.status {
  margin-top: 8px;
  font-size: 13px;
}
</style>
</head>
<body>
<header>
  <h2 style="margin:0">Grid Web Synth — New Timbres</h2>
  <div class="small">Now includes Organ and Electric Guitar harmonic profiles.</div>
</header>

<div class="controls">
  <label>Rows
    <input id="rows" type="number" min="1" max="4294967296" value="6" />
  </label>

  <label>Cols
    <input id="cols" type="number" min="1" max="4294967296" value="12" />
  </label>

  <label>Key size (px)
    <input id="keySize" type="number" min="8" max="200" value="64" />
  </label>

  <label>Tuning type
    <select id="tuningType">
      <option value="edo">EDO</option>
      <option value="nonoctave">Nonoctave (xedY)</option>
      <option value="ji">Just Intonation (prime limit)</option>
    </select>
  </label>

  <label id="edoParams">EDO steps
    <input id="edoSteps" type="number" min="2" max="4294967296" value="12" />
  </label>

  <label id="nonoParams" style="display:none">Nonoctave (format `xedY`, e.g. `13ed3`)
    <input id="nonoSpec" type="text" placeholder="13ed3" value="13ed3" />
  </label>

  <label id="jiParams" style="display:none">Prime limit
    <input id="jiPrime" type="number" min="2" max="97" value="5" />
  </label>

  <label>Root note (name)
    <input id="rootNoteName" type="text" value="C4" />
  </label>

  <label>Root frequency (Hz)
    <input id="rootFreq" type="number" min="1" max="20000" value="261.6256" step="0.0001" />
  </label>

  <div style="display:flex;gap:8px;align-items:center;">
    <button id="applyBtn">Apply</button>
    <button id="randomizeBtn">Randomize</button>
    <button id="stopAllBtn" title="Stop all playing voices">Stop All</button>
  </div>

  <div style="flex:1"></div>

  <!-- Volume Slider -->
  <label>Volume
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.8" />
  </label>
  
  <!-- Sustain Toggle -->
  <label>Sustain
    <input id="sustainToggle" type="checkbox" />
  </label>

  <label>Waveform
    <select id="wave">
      <option>sine</option>
      <option>triangle</option>
      <option>sawtooth</option>
      <option>square</option>
      <option>piano</option>
      <option>guitar</option>
      <option>violin</option>
      <!-- ADDED NEW TIMBRES -->
      <option>organ</option>
      <option>electric_guitar</option>
    </select>
  </label>

  <label>Release (ms)
    <input id="release" type="number" min="5" max="10000" value="120" />
  </label>
</div>

<div id="gridWrap">
  <canvas id="gridCanvas"></canvas>
</div>

<div class="status">
  <div id="tuningText">Tuning: —</div>
  <div class="small" id="notesLegend"></div>
</div>

<script>
/* Fixed Grid Web Synth: (1) use chromatic for #/b, (2) robust pointer+voice handling. */

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioCtx.createGain();
// masterGain gain value is initialized below by the volume slider
masterGain.connect(audioCtx.destination);

const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', { alpha:false });

// UI
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const keySizeInput = document.getElementById('keySize');
const tuningType = document.getElementById('tuningType');
const edoStepsInput = document.getElementById('edoSteps');
const nonoParams = document.getElementById('nonoParams');
const nonoSpecInput = document.getElementById('nonoSpec');
const jiParams = document.getElementById('jiParams');
const jiPrimeInput = document.getElementById('jiPrime');
const rootFreqInput = document.getElementById('rootFreq');
const rootNoteNameInput = document.getElementById('rootNoteName');
const applyBtn = document.getElementById('applyBtn');
const randomizeBtn = document.getElementById('randomizeBtn');
const tuningText = document.getElementById('tuningText');
const notesLegend = document.getElementById('notesLegend');
const waveSel = document.getElementById('wave');
const releaseInput = document.getElementById('release');
const edoParams = document.getElementById('edoParams');
// Volume Slider, Sustain Toggle, and Stop All Button
const volumeSlider = document.getElementById('volumeSlider');
const sustainToggle = document.getElementById('sustainToggle');
const stopAllBtn = document.getElementById('stopAllBtn');


// Set initial volume and add listener
if(volumeSlider) {
  masterGain.gain.value = parseFloat(volumeSlider.value);
  volumeSlider.addEventListener('input', (e) => {
    masterGain.gain.value = parseFloat(e.target.value);
  });
}


tuningType.addEventListener('change', () => {
  const v = tuningType.value;
  edoParams.style.display = v === 'edo' ? '' : 'none';
  nonoParams.style.display = v === 'nonoctave' ? '' : 'none';
  jiParams.style.display = v === 'ji' ? '' : 'none';
});

/* helpers (unchanged) */
function centsOfRatio(r){ return 1200 * Math.log2(r); }
function parseRatioString(s){
  s = String(s).trim();
  if(!s) return NaN;
  if(s.includes('/')){
    const [a,b] = s.split('/').map(x=>parseFloat(x.trim()));
    if(isFinite(a) && isFinite(b) && b!==0) return a/b;
    return NaN;
  } else {
    const v = parseFloat(s);
    return isFinite(v) ? v : NaN;
  }
}

/* canonical chain Fb..B# (unchanged) */
const canonicalChainOfFifths = [
  "Dbb", "Abb", "Ebb", "Bbb", "Fb","Cb","Gb","Db","Ab","Eb","Bb","F",
  "C","G","D","A","E","B","F#","C#",
  "G#","D#","A#","E#","B#", "Fx", "Cx"
];

/* EDO naming (unchanged) */
function generateEDONaming(N){
  const kfloat = N * Math.log2(3/2);
  const k = Math.round(kfloat);
  const wholeTone = (2 * k) % N;
  const chromaticRaw = (7 * k) - (4 * N);
  const chromatic = ((chromaticRaw % N) + N) % N;
  const diatonic = ((wholeTone - chromatic) % N + N) % N;

  // offsets of letters in fifths from C
  const fifthOffsets = { 'C':0, 'G':1, 'D':2, 'A':3, 'E':4, 'B':5, 'F':-1 };
  const letterSteps = {};
  for(const [L, offs] of Object.entries(fifthOffsets)){
    let pos = (offs * k) % N;
    pos = (pos + N) % N;
    letterSteps[L] = pos;
  }

  function canonicalNameToStep(name){
    const letter = name[0];
    const rest = name.slice(1);
    let base = letterSteps[letter] ?? 0;
    // FIX: apply chromatic for sharps/flats (raise/lower by chromatic semitone)
    for(const ch of rest){
      if(ch === '#') base = (base + chromatic) % N;
      else if(ch === 'b') base = (base - chromatic + N) % N;
    }
    return (base + N) % N;
  }

  const stepToCanonicalNames = new Map();
  for(const cname of canonicalChainOfFifths){
    const s = canonicalNameToStep(cname);
    if(!stepToCanonicalNames.has(s)) stepToCanonicalNames.set(s, []);
    stepToCanonicalNames.get(s).push(cname);
  }

  const canonicalSteps = Array.from(stepToCanonicalNames.keys());
  const names = Array.from({length:N}, ()=>[]);

  for(const [s,list] of stepToCanonicalNames.entries()) names[s] = [...new Set(list)];

  // fill other steps by nearest canonical step (prefix ^ or v)
  for(let s=0; s<N; s++){
    if(names[s].length > 0) continue;
    let best = null; let bestAbs = Infinity; let bestSigned = 0; let bestCanonicalStep = null;
    for(const cs of canonicalSteps){
      let signed = ((s - cs + N) % N);
      if(signed > N/2) signed -= N;
      const absd = Math.abs(signed);
      if(absd < bestAbs){
        bestAbs = absd; bestSigned = signed; bestCanonicalStep = cs;
      }
    }
    const baseNames = stepToCanonicalNames.get(bestCanonicalStep) || ['?'];
    const prefList = baseNames.map(bn => {
      if(bestSigned > 0) return '^'.repeat(bestSigned) + bn;
      if(bestSigned < 0) return 'v'.repeat(-bestSigned) + bn;
      return bn;
    });
    names[s] = prefList;
  }

  return { names, info: {k, wholeTone, chromaticRaw, chromatic, diatonic} };
}

// map canonical note names to their fifthspan relative to C (unchanged)
const fifthspanMap = {};
canonicalChainOfFifths.forEach((name, i) => {
  const span = i - canonicalChainOfFifths.indexOf("C");
  fifthspanMap[name] = span;
});

function pickSimplestName(list){
  if(!Array.isArray(list) || list.length===0) return '?';
  const uniq = Array.from(new Set(list));

  function analyze(n){
    let s = n;
    // peel off ^ / v prefixes (non-canonical displacement)
    let prefixShift = 0;
    while(s[0] === '^' || s[0] === 'v'){
      prefixShift += (s[0] === '^' ? 1 : -1);
      s = s.slice(1);
    }
    const core = s;
    const spanFromC = (fifthspanMap[core] ?? 0) + prefixShift;
    const absSpan = Math.abs(spanFromC);

    const isNatural = /^[A-G]$/.test(core);
    const sharps = (core.match(/#/g)||[]).length;
    const flats = (core.match(/b/g)||[]).length;
    const accidentalCount = sharps + flats;
    const kindScore = isNatural ? 0 : (sharps>0 ? 1 : (flats>0 ? 2 : 3));

    return {orig: n, absSpan, kindScore, accidentalCount, length: n.length};
  }

  const analyzed = uniq.map(s => ({s, a: analyze(s)}));
  analyzed.sort((A,B)=>{
    if(A.a.absSpan !== B.a.absSpan) return A.a.absSpan - B.a.absSpan;  // smallest absolute fifthspan
    if(A.a.kindScore !== B.a.kindScore) return A.a.kindScore - B.a.kindScore;
    if(A.a.accidentalCount !== B.a.accidentalCount) return A.a.accidentalCount - B.a.accidentalCount;
    if(A.a.length !== B.a.length) return A.a.length - B.a.length;
    return A.s.localeCompare(B.s);
  });
  return analyzed[0].s;
}

/* nonoctave parse & find EDO approx (unchanged) */
function parseNonoSpec(spec){
  const m = String(spec).trim().match(/^(\d+)\s*ed\s*(.+)$/i);
  if(!m) return null;
  const x = parseInt(m[1],10);
  const ratio = parseRatioString(m[2]);
  if(!isFinite(ratio) || ratio <= 0) return null;
  return {x, ratio};
}
function findEDOApproxForNono(x, ratio){
  const stepRatio = Math.pow(ratio, 1 / x);
  const stepCents = centsOfRatio(stepRatio);
  let best = null;
  for(let M=13; M<=4294967296; M++){
    const raw = M * Math.log2(stepRatio);
    const s = Math.round(raw);
    const err = Math.abs(raw - s);
    if(err <= 0.1) return {M, s, raw, err, stepCents};
    if(!best || err < best.err) best = {M, s, raw, err, stepCents};
  }
  return best;
}

/* JI generation (unchanged) */
function primesUpTo(n){
  const sieve = new Array(n+1).fill(true);
  sieve[0]=sieve[1]=false;
  for(let p=2;p*p<=n;p++) if(sieve[p]) for(let q=p*p;q<=n;q+=p) sieve[q]=false;
  const ps=[];
  for(let i=2;i<=n;i++) if(sieve[i]) ps.push(i);
  return ps;
}
function factorOk(n, allowedPrimes){
  let m = Math.abs(Math.round(n));
  if(m === 0) return false;
  for(const p of allowedPrimes){
    while(m % p === 0) m = m / p;
  }
  return m === 1;
}
function generateJIRatios(primeLimit, maxNumDen=16){
  const allowedPrimes = primesUpTo(primeLimit);
  const ratios = new Set();
  for(let num=1; num<=maxNumDen; num++){
    if(!factorOk(num, allowedPrimes)) continue;
    for(let den=1; den<=maxNumDen; den++){
      if(!factorOk(den, allowedPrimes)) continue;
      let r = num / den;
      while(r >= 2) r /= 2;
      while(r < 1) r *= 2;
      if(r >=1 && r < 2) ratios.add(r);
    }
  }
  const arr = Array.from(ratios).sort((a,b)=>centsOfRatio(a) - centsOfRatio(b));
  return arr;
}

/* state (unchanged) */
let gridState = {
  rows: 6, cols: 12, keySize: 64,
  tuning: { type:'edo', edo:12 },
  rootFreq: 261.6256, rootName: 'C4',
  edoNameTable: null, nonoInfo: null, jiRatios: null
};

function buildStateFromUI(){
  const rows = Math.max(1, Math.min(4294967296, parseInt(rowsInput.value) || 6));
  const cols = Math.max(1, Math.min(4294967296, parseInt(colsInput.value) || 12));
  const keySize = Math.max(8, Math.min(200, parseInt(keySizeInput.value) || 64));
  const rootFreq = Math.max(1, Math.min(20000, parseFloat(rootFreqInput.value) || 261.6256));
  const rootName = rootNoteNameInput.value || 'root';
  const type = tuningType.value;

  gridState.rows = rows; gridState.cols = cols; gridState.keySize = keySize;
  gridState.rootFreq = rootFreq; gridState.rootName = rootName;

  if(type === 'edo'){
    const N = Math.max(2, Math.min(4294967296, parseInt(edoStepsInput.value) || 12));
    gridState.tuning = { type:'edo', edo: N };
    gridState.edoNameTable = generateEDONaming(N).names;
    gridState.nonoInfo = null; gridState.jiRatios = null;
    tuningText.textContent = `${N}-EDO (names generated from chain-of-fifths)`;
  } else if(type === 'nonoctave'){
    const parsed = parseNonoSpec(nonoSpecInput.value);
    if(!parsed){ console.error('Invalid nonoctave spec.'); return false; }
    const approx = findEDOApproxForNono(parsed.x, parsed.ratio);
    gridState.tuning = { type:'nonoctave', x: parsed.x, ratio: parsed.ratio };
    gridState.nonoInfo = { parsed, approx };
    if(approx && approx.M){
      gridState.edoNameTable = generateEDONaming(approx.M).names;
      tuningText.textContent = `${parsed.x}ed${parsed.ratio} → approx ${approx.M}-EDO (s=${approx.s})`;
    } else {
      gridState.edoNameTable = generateEDONaming(31).names;
      tuningText.textContent = `${parsed.x}ed${parsed.ratio} (no close EDO found)`;
    }
    gridState.jiRatios = null;
  } else if(type === 'ji'){
    const p = Math.max(2, Math.min(97, parseInt(jiPrimeInput.value) || 5));
    gridState.tuning = { type:'ji', prime: p };
    gridState.jiRatios = generateJIRatios(p, 20);
    gridState.edoNameTable = null; gridState.nonoInfo = null;
    tuningText.textContent = `JI (prime ≤ ${p}) — ${gridState.jiRatios.length} ratios`;
  } else return false;

  return true;
}

/* frequency & labeling (unchanged) */
function frequencyForIndex(idx){
  const t = gridState.tuning; const root = gridState.rootFreq;
  if(t.type === 'edo'){
    return root * Math.pow(2, idx / t.edo);
  } else if(t.type === 'nonoctave'){
    const { x, ratio } = t;
    const stepRatio = Math.pow(ratio, 1/x);
    return root * Math.pow(stepRatio, idx);
  } else if(t.type === 'ji'){
    const ratios = gridState.jiRatios || [1];
    if(!ratios.length) return root;
    const step = idx % ratios.length;
    const octaveShift = Math.floor(idx / ratios.length);
    return root * ratios[step] * Math.pow(2, octaveShift);
  }
  return root;
}
function prettyRatioName(r){
  const maxDen = 64; let best={err:Infinity,n:1,d:1};
  for(let d=1; d<=maxDen; d++){
    const n=Math.round(r*d); const err=Math.abs(r - n/d);
    if(err<best.err) best={err,n,d};
  }
  return `${best.n}/${best.d} (${centsOfRatio(r).toFixed(2)}c)`;
}
function nameForIndex(idx){
  const t = gridState.tuning;
  if(t.type === 'edo'){
    const step = ((idx % t.edo)+t.edo)%t.edo;
    const candidates = gridState.edoNameTable[step] || [];
    return pickSimplestName(candidates);
  } else if(t.type === 'nonoctave'){
    const info = gridState.nonoInfo;
    if(info && info.approx && info.approx.M && typeof info.approx.s === 'number'){
      const M = info.approx.M, s = info.approx.s;
      const step = (((idx * s) % M) + M) % M;
      const candidates = gridState.edoNameTable[step] || [];
      return pickSimplestName(candidates);
    } else return `step ${idx}`;
  } else if(t.type === 'ji'){
    const ratios = gridState.jiRatios || [1];
    if(ratios.length===0) return '?';
    return prettyRatioName(ratios[idx % ratios.length]);
  }
  return '?';
}

/* canvas draw (unchanged) */
function resizeCanvas(){
  const ks = gridState.keySize;
  const width = gridState.cols * ks;
  const height = gridState.rows * ks;
  canvas.width = width; canvas.height = height;
  canvas.style.width = Math.min(width, window.innerWidth - 40) + 'px';
  canvas.style.height = Math.min(height, window.innerHeight * 0.64) + 'px';
}
function renderGrid(){
  const ks = gridState.keySize, rows = gridState.rows, cols = gridState.cols;
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
  ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x=c*ks, y=r*ks; ctx.fillStyle='#fff'; ctx.fillRect(x,y,ks,ks); ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);
      const idx=r*cols+c; let label = nameForIndex(idx);
      ctx.fillStyle='#111'; let disp=String(label); if(disp.length>14) disp = disp.slice(0,12)+'…';
      ctx.fillText(disp, x+ks/2, y+ks/2);
    }
  }
}

/* --- EDITED: PeriodicWave Definitions for Timbres (Up to 16th Harmonic) --- */

function getPeriodicWave(type) {
    let real; // Cosine components (amplitudes/volumes of the harmonics)
    let imag; // Sine components (we keep these zero for simplicity)
    const maxHarmonics = 16; // Up to the 16th harmonic (17 elements total: DC offset + 16 harmonics)

    // Helper to create zero-filled imag array
    const createImag = (len) => new Float32Array(len).fill(0);

    // Harmonic data starts at index 1: real[0] is the DC offset (ignored for timbre)
    if (type === 'piano') {
        real = new Float32Array([0, 1.0, 0.5, 0.4, 0.3, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002, 0.0001, 0.00005]);
    } else if (type === 'guitar') {
        real = new Float32Array([0, 1.0, 0.1, 0.7, 0.0, 0.4, 0.0, 0.2, 0.0, 0.1, 0.0, 0.05, 0.0, 0.0, 0.0, 0.03, 0.0]);
    } else if (type === 'violin') {
        real = new Float32Array([0, 1.0, 0.8, 0.6, 0.5, 0.4, 0.3, 0.25, 0.2, 0.15, 0.1, 0.08, 0.05, 0.04, 0.03, 0.02, 0.01]);
    } 
    // NEW TIMBRE 1: ORGAN (Mellow drawbar style)
    else if (type === 'organ') {
        // Strong Fundamental, Octave (2nd), and 12th (3rd harmonic of 2nd oct) for a sustained, rich tone.
        real = new Float32Array([0, 1.0, 0.8, 0.2, 0.4, 0.8, 0.05, 0.04, 0.03, 0.02, 0.01, 0.005, 0.003, 0.002, 0.001, 0.0005, 0.0001]);
    } 
    // NEW TIMBRE 2: ELECTRIC GUITAR (Overdriven/Fuzz)
    else if (type === 'electric_guitar') {
        // Heavy emphasis on ODD harmonics (3, 5, 7, 9) to simulate distortion/square wave clipping.
        real = new Float32Array([0, 1.0, 0.1, 0.45, 0.1, 0.7, 0.1, 0.5, 0.05, 0.3, 0.0, 0.1, 0.0, 0.05, 0.0, 0.02, 0.0]);
    }
    else {
        // Fallback or unrecognized type (default to sine wave setup)
        return null;
    }
    
    // Ensure arrays are the same length (DC offset + maxHarmonics)
    if (real.length < maxHarmonics + 1) {
      real = new Float32Array([...real, ...Array(maxHarmonics + 1 - real.length).fill(0)]);
    }

    imag = createImag(real.length);
    
    // Create and return the custom waveform
    return audioCtx.createPeriodicWave(real, imag, { disableNormalization: true });
}

/* Audio voices & robust pointer handling */
const activeVoices = new Map(); // idx -> {osc,gain}
const pointerToIdx = new Map(); // pointerId -> idx

// Function to stop all playing voices (unchanged)
function stopAllVoices() {
  const now = audioCtx.currentTime;
  // Get keys before iterating as noteOff deletes from the map
  const voicesToStop = Array.from(activeVoices.keys()); 

  for(const idx of voicesToStop) {
    // Manually trigger the note-off envelope for all active voices
    const v = activeVoices.get(idx);
    if(v) {
        const rel = Math.max(5, parseFloat(releaseInput.value) || 120) / 1000;
        try {
          v.gain.gain.cancelScheduledValues(now);
          v.gain.gain.setValueAtTime(v.gain.gain.value, now);
          v.gain.gain.exponentialRampToValueAtTime(0.0001, now + rel);
          v.osc.stop(now + rel + 0.02);
        } catch(e){}
        setTimeout(()=>{ try{ v.osc.disconnect(); v.gain.disconnect(); }catch(_){} }, (rel+0.05)*1000);
        activeVoices.delete(idx);
    }
    // Update UI
    drawKeyActive(idx, false);
  }

  // Clear all pointers being tracked
  pointerToIdx.clear();
  renderGrid(); // Redraw the entire grid to ensure keys are reset
}

// Attach stopAllVoices to the new button (unchanged)
if(stopAllBtn) stopAllBtn.addEventListener('click', stopAllVoices);


function noteOn(idx){
  if(activeVoices.has(idx)) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  
  const selectedWave = waveSel.value;
  
  // --- MODIFIED LOGIC TO SUPPORT NEW TIMBRES ---
  if (selectedWave === 'sine' || selectedWave === 'triangle' || selectedWave === 'sawtooth' || selectedWave === 'square') {
      osc.type = selectedWave;
  } else {
      const customWave = getPeriodicWave(selectedWave);
      if (customWave) {
          osc.setPeriodicWave(customWave);
      } else {
          // Fallback if something goes wrong or selection is unknown
          osc.type = 'sine';
      }
  }
  // --- END MODIFIED LOGIC ---

  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(1.0, audioCtx.currentTime + 0.01);
  osc.connect(g); g.connect(masterGain);
  osc.frequency.value = frequencyForIndex(idx);
  osc.start();
  activeVoices.set(idx, {osc, gain: g});
}

function noteOff(idx){
  const v = activeVoices.get(idx);
  if(!v) return;
  
  const rel = Math.max(5, parseFloat(releaseInput.value) || 120) / 1000;
  const now = audioCtx.currentTime;
  try {
    v.gain.gain.cancelScheduledValues(now);
    v.gain.gain.setValueAtTime(v.gain.gain.value, now);
    v.gain.gain.exponentialRampToValueAtTime(0.0001, now + rel);
    v.osc.stop(now + rel + 0.02);
  } catch(e){}
  setTimeout(()=>{ try{ v.osc.disconnect(); v.gain.disconnect(); }catch(_){} }, (rel+0.05)*1000);
  activeVoices.delete(idx);
}

/* coordinate -> index (unchanged) */
function canvasPosToIndex(evt){
  const rect = canvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  const c = Math.floor(x / gridState.keySize);
  const r = Math.floor(y / gridState.keySize);
  if(c < 0 || c >= gridState.cols || r < 0 || r >= gridState.rows) return null;
  return r * gridState.cols + c;
}

/* pointer handlers (unchanged, includes sustain logic) */
canvas.addEventListener('pointerdown', (e) => {
  if(audioCtx.state === 'suspended') audioCtx.resume();
  e.preventDefault();
  const idx = canvasPosToIndex(e);
  if(idx === null) return;
  try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
  pointerToIdx.set(e.pointerId, idx);
  noteOn(idx);
  drawKeyActive(idx, true);
});

canvas.addEventListener('pointermove', (e) => {
  if(!pointerToIdx.has(e.pointerId)) return;
  e.preventDefault();
  const prevIdx = pointerToIdx.get(e.pointerId);
  const idx = canvasPosToIndex(e);
  if(idx === prevIdx) return;

  // stop previous ONLY if sustain is OFF
  if(prevIdx !== null) {
    if(!sustainToggle.checked) {
      noteOff(prevIdx);
    }
    drawKeyActive(prevIdx, false);
  }
  
  // start new if valid
  if(idx !== null){
    noteOn(idx); 
    drawKeyActive(idx, true); 
    pointerToIdx.set(e.pointerId, idx); 
  } else {
    pointerToIdx.set(e.pointerId, null);
  }
});

canvas.addEventListener('pointerup', (e) => {
  e.preventDefault();
  const idx = pointerToIdx.get(e.pointerId);
  if(typeof idx === 'number' && idx !== null){
    // ONLY stop the note if sustain is OFF
    if(!sustainToggle.checked) {
      noteOff(idx);
    }
    drawKeyActive(idx, false);
  }
  pointerToIdx.delete(e.pointerId);
  try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
});

canvas.addEventListener('pointercancel', (e) => {
  e.preventDefault();
  const idx = pointerToIdx.get(e.pointerId);
  if(typeof idx === 'number' && idx !== null){
    // ONLY stop the note if sustain is OFF
    if(!sustainToggle.checked) {
      noteOff(idx);
    }
    drawKeyActive(idx, false);
  }
  pointerToIdx.delete(e.pointerId);
});

/* drawKeyActive (unchanged) */
function drawKeyActive(idx, active){
  const ks = gridState.keySize;
  const r = Math.floor(idx / gridState.cols);
  const c = idx % gridState.cols;
  const x = c*ks, y=r*ks;
  if(active) ctx.fillStyle = '#e6f7ff'; else ctx.fillStyle = '#fff';
  ctx.fillRect(x+1,y+1,ks-2,ks-2);
  ctx.strokeStyle='#ddd'; ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);
  const lab = nameForIndex(idx);
  ctx.fillStyle='#111'; ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  let disp = String(lab); if(disp.length>14) disp = disp.slice(0,12)+'…';
  ctx.fillText(disp, x+ks/2, y+ks/2);
}

/* buttons and init (unchanged) */
applyBtn.addEventListener('click', () => {
  const ok = buildStateFromUI(); if(!ok) return;
  resizeCanvas(); renderGrid(); updateLegend();
});
randomizeBtn.addEventListener('click', () => {
  const t = tuningType.value;
  if(t === 'edo'){ const v = Math.floor(5 + Math.random()*48); edoStepsInput.value = v; }
  else if(t === 'nonoctave'){ const x = Math.floor(5 + Math.random()*40); const rnum = [3,5,7,9,2,4][Math.floor(Math.random()*6)]; nonoSpecInput.value = `${x}ed${rnum}`; }
  else jiPrimeInput.value = [3,5,7,11,13,17][Math.floor(Math.random()*6)];
  const ok = buildStateFromUI(); if(!ok) return;
  resizeCanvas(); renderGrid(); updateLegend();
});

function updateLegend(){
  const t = gridState.tuning;
  let txt = `Grid: ${gridState.rows}×${gridState.cols} • Key size: ${gridState.keySize}px • Root: ${gridState.rootName} @ ${gridState.rootFreq} Hz. `;
  if(t.type === 'edo') txt += `${t.edo}-EDO (names Fb→B#).`;
  else if(t.type === 'nonoctave'){
    txt += `${t.x}ed${t.ratio}. `;
    if(gridState.nonoInfo && gridState.nonoInfo.approx) txt += `Approx: ${gridState.nonoInfo.approx.M}-EDO, s=${gridState.nonoInfo.approx.s}.`;
    else txt += 'No close EDO approximation found.';
  } else if(t.type === 'ji') txt += `JI (prime ≤ ${t.prime}), ${ (gridState.jiRatios||[]).length } ratios.`;
  notesLegend.textContent = txt;
}

/* init */
buildStateFromUI();
resizeCanvas();
renderGrid();
updateLegend();

window.addEventListener('resize', () => { resizeCanvas(); renderGrid(); });

</script>
</body>
</html>