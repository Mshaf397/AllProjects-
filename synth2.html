<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grid Web Synth — Circle of Fifths Generator</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    --pad: 10px;
    --main-bg: #1E90FF; /* DodgerBlue */
    --control-bg: #323ddd;
    --text-color: #f1f1f1; /* Changed for better contrast */
    --button-color: #12e34b; /* Bright green */
    --key-color: #228222; /* ForestGreen */
    font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  body {
    margin: 0;
    padding: var(--pad);
    background: var(--main-bg);
    color: var(--text-color);
  }

  header {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 8px;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: end;
    background: var(--control-bg);
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  }

  label {
    font-size: 13px;
    display: flex;
    flex-direction: column;
    min-width: 120px;
    color: white;
  }

  input[type="range"] {
    height: 30px;
    cursor: grab;
  }

  input[type="number"],
  input[type="text"],
  select {
    padding: 6px;
    font-size: 14px;
    border-radius: 4px;
    color: #111;
  }
  
  input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-top: 5px;
  }

  select[multiple] {
    padding: 4px;
    border: 1px solid #ddd;
    background: white;
    min-height: 100px;
    box-sizing: border-box;
    color: #111;
  }

  button {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    border-radius: 4px;
    background: var(--button-color);
    color: var(--control-bg);
    border: none;
    font-weight: bold;
    transition: background 0.1s, transform 0.1s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  button:hover {
    background: #0fbc3c;
    transform: translateY(-1px);
  }

  #gridWrap {
    margin-top: 12px;
    border-radius: 8px;
    overflow: auto;
    background: var(--control-bg);
    padding: 8px;
    /* Use dynamic height for responsiveness */
    max-height: 60vh; 
  }
  @media (max-width: 768px) {
    #gridWrap {
      max-height: 40vh;
    }
  }

  canvas {
    display: block;
    background: var(--key-color);
    border-radius: 4px;
    /* Ensures canvas scales fluidly within its wrapper */
    max-width: 100%;
    height: auto;
  }

  .small {
    font-size: 12px;
    color: var(--button-color);
  }
  
  .status {
    margin-top: 12px;
    color: white;
    padding: 8px;
    border-radius: 4px;
    background: rgba(0,0,0,0.2);
  }

  /* MODAL STYLES */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: white;
    padding: 24px;
    border-radius: 8px;
    width: 90%;
    max-width: 400px;
    color: #111;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  }
  .modal-content h3 {
    margin-top: 0;
    color: var(--control-bg);
  }
  .modal-content .modal-controls {
    display: flex;
    justify-content: flex-end;
    margin-top: 20px;
    gap: 10px;
  }
  .modal-content label {
      color: #333;
      margin-bottom: 8px;
  }
  .modal-content input {
      width: 100%;
      box-sizing: border-box;
      color: #111;
  }
</style>
</head>
<body>
<header>
  <h2 style="margin:0">Grid Web Synth — Circle of Fifths Generator</h2>
  <div class="small">Scale generation uses the currently selected EDO Steps (N) for quantization.</div>
</header>

<div class="controls">
  <label>Rows
    <input id="rows" type="number" min="1" max="4294967296" value="6" />
  </label>

  <label>Cols
    <input id="cols" type="number" min="1" max="4294967296" value="12" />
  </label>

  <label>Key size (px)
    <input id="keySize" type="number" min="8" max="200" value="64" />
  </label>

  <label>Tuning type
    <select id="tuningType">
      <option value="edo">EDO</option>
      <!-- Non-octave and JI tunings are currently placeholders -->
      <option value="nonoctave">Nonoctave (xedY)</option>
      <option value="ji">Just Intonation (prime limit)</option>
    </select>
  </label>

  <label id="edoParams">EDO steps (N)
    <input id="edoSteps" type="number" min="2" max="4294967296" value="12" />
  </label>

  <label id="nonoParams" style="display:none">Nonoctave (format `xedY`, e.g. `13ed3`)
    <input id="nonoSpec" type="text" placeholder="13ed3" value="13ed3" />
  </label>

  <label id="jiParams" style="display:none">Prime limit
    <input id="jiPrime" type="number" min="2" max="97" value="5" />
  </label>

  <label>Root note (name)
    <input id="rootNoteName" type="text" value="C4" />
  </label>

  <label>Root frequency (Hz)
    <input id="rootFreq" type="number" min="1" max="20000" value="261.6256" step="0.0001" />
  </label>

  <label style="min-width: 250px;">Scale Subset (Select Notes)
    <select id="scaleSubset" multiple size="6"></select>
    <div class="small mt-1">(Hold Ctrl/Cmd to select multiple)</div>
  </label>

  <div style="display:flex;gap:8px;align-items:center;">
    <button id="applyBtn">Apply Tuning</button>
    <button id="generateScaleBtn">Generate Scale Subset</button>
    <button id="stopAllBtn" title="Stop all playing voices">Stop All</button>
  </div>

  <div style="flex:1"></div>

  <!-- Volume Slider -->
  <label>Volume
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.8" />
  </label>

  <!-- Sustain Toggle -->
  <label>Sustain
    <input id="sustainToggle" type="checkbox" checked />
  </label>

  <label>Waveform
    <select id="wave">
      <option>sine</option>
      <option>triangle</option>
      <option>sawtooth</option>
      <option>square</option>
      <option>piano</option>
      <option>guitar</option>
      <option>violin</option>
      <option>organ</option>
      <option>electric_guitar</option>
    </select>
  </label>

  <label>Release (ms)
    <input id="release" type="number" min="5" max="10000" value="120" />
  </label>
</div>

<div id="gridWrap">
  <canvas id="gridCanvas"></canvas>
</div>

<div class="status">
  <div id="tuningText">Tuning: —</div>
  <div class="small" id="notesLegend"></div>
</div>

<!-- SCALE GENERATOR MODAL -->
<div id="scaleGeneratorModal" class="modal-overlay">
    <div class="modal-content">
        <h3>Circle-of-Fifths Scale Generator</h3>
        <p class="small" style="color:#666;">This tool uses the current **EDO Steps (N)** value for quantization.</p>

        <label>Generator (Ratio x/y, Cents, or EDO Steps x\y, e.g., 3/2 or 7\12):
          <input id="gen_generator" value="700">
        </label>
        <label>Period (Ratio x/y, Cents, or EDO Steps x\y, e.g., 2/1 or 12\12):
          <input id="gen_period" value="1200">
        </label>
        <label>UDP (e.g., up|down(periods), like 3|3(1)):
          <input id="gen_udp" value="3|3(1)">
        </label>

        <div class="modal-controls">
            <button id="gen_cancelBtn" style="background:#ccc; color:#333;">Cancel</button>
            <button id="gen_applyBtn">Generate & Apply</button>
        </div>
    </div>
</div>
<!-- /MODAL -->

<script>
// --- WEB AUDIO API SETUP ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);

// Synth Class for Audio Generation and ADSR
class Synth {
    constructor(ctx, gainNode, waveType, releaseTime) {
        this.ctx = ctx;
        this.masterGain = gainNode;
        this.releaseTime = releaseTime / 1000;
        this.gain = ctx.createGain();
        this.gain.gain.setValueAtTime(0, ctx.currentTime);
        this.gain.connect(this.masterGain);

        this.oscillators = [];
        this.waveType = waveType;
        
        this.initOscillators();
    }

    initOscillators() {
        const createOsc = (type, gainValue, multiplier = 1) => {
            const osc = this.ctx.createOscillator();
            osc.type = type;
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(gainValue, this.ctx.currentTime);
            osc.connect(g).connect(this.gain);
            this.oscillators.push({ osc, multiplier });
        };

        const types = {
            'sine': [{type:'sine', gain:1}],
            'triangle': [{type:'triangle', gain:1}],
            'sawtooth': [{type:'sawtooth', gain:1}],
            'square': [{type:'square', gain:1}],
            // Simple additive approximations for instrument sounds
            'piano': [{type:'sine', gain:1}, {type:'triangle', gain:0.5, mult: 2}],
            'guitar': [{type:'sawtooth', gain:1}, {type:'square', gain:0.4, mult: 3}],
            'violin': [{type:'sawtooth', gain:1}, {type:'sine', gain:0.6, mult: 2}, {type:'triangle', gain:0.3, mult: 4}],
            'organ': [{type:'square', gain:1}, {type:'square', gain:0.5, mult: 2}, {type:'sine', gain:0.3, mult: 3}],
            'electric_guitar': [{type:'square', gain:1}, {type:'sawtooth', gain:0.6, mult: 2}],
        };
        
        const config = types[this.waveType] || types['sine'];

        config.forEach(c => {
            createOsc(c.type, c.gain, c.mult);
        });
        
        this.oscillators.forEach(item => {
            item.osc.start();
        });
    }

    start(frequency) {
        const now = this.ctx.currentTime;
        
        // Update frequencies
        this.oscillators.forEach(item => {
            const freq = frequency * (item.multiplier || 1);
            item.osc.frequency.setValueAtTime(freq, now);
        });

        // Simple Attack to Sustain
        this.gain.gain.cancelScheduledValues(now);
        this.gain.gain.setValueAtTime(0, now);
        this.gain.gain.linearRampToValueAtTime(1 * this.masterGain.gain.value, now + 0.005); // Attack
    }

    release() {
        const now = this.ctx.currentTime;
        this.gain.gain.cancelScheduledValues(now);
        this.gain.gain.setValueAtTime(this.gain.gain.value, now);
        this.gain.gain.linearRampToValueAtTime(0, now + this.releaseTime);
        
        // Stop oscillators after release time
        this.oscillators.forEach(item => {
            try {
                item.osc.stop(now + this.releaseTime + 0.05); // Add small buffer
            } catch (e) {
                // Oscillator may already be stopped if rapid note-on/off occurs
            }
        });
    }
}


// --- UI ELEMENTS ---
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const keySizeInput = document.getElementById('keySize');
const tuningType = document.getElementById('tuningType');
const edoStepsInput = document.getElementById('edoSteps');
const nonoParams = document.getElementById('nonoParams');
const nonoSpecInput = document.getElementById('nonoSpec');
const jiParams = document.getElementById('jiParams');
const jiPrimeInput = document.getElementById('jiPrime');
const rootFreqInput = document.getElementById('rootFreq');
const rootNoteNameInput = document.getElementById('rootNoteName');
const scaleSubsetSelect = document.getElementById('scaleSubset');
const applyBtn = document.getElementById('applyBtn');
const tuningText = document.getElementById('tuningText');
const notesLegend = document.getElementById('notesLegend');
const waveSel = document.getElementById('wave');
const releaseInput = document.getElementById('release');
const edoParams = document.getElementById('edoParams');
const volumeSlider = document.getElementById('volumeSlider');
const sustainToggle = document.getElementById('sustainToggle');
const stopAllBtn = document.getElementById('stopAllBtn');
const generateScaleBtn = document.getElementById('generateScaleBtn'); 
const scaleGeneratorModal = document.getElementById('scaleGeneratorModal');
const gen_generator = document.getElementById('gen_generator');
const gen_period = document.getElementById('gen_period');
const gen_udp = document.getElementById('gen_udp');
const gen_cancelBtn = document.getElementById('gen_cancelBtn');
const gen_applyBtn = document.getElementById('gen_applyBtn');

// --- AUDIO/SYNTH STATE ---
const activeVoices = new Map(); 
const pointerToIdx = new Map(); 

if(volumeSlider) {
  masterGain.gain.value = parseFloat(volumeSlider.value);
  volumeSlider.addEventListener('input', (e) => {
    masterGain.gain.value = parseFloat(e.target.value);
  });
}

// --- HELPER FUNCTIONS ---
function centsOfRatio(r){ return 1200 * Math.log2(r); }

/**
 * Parses an interval string into cents. Handles:
 * 1. EDO steps: x\y (e.g., 7\12) -> 1200 * x/y
 * 2. Ratio: x/y (e.g., 3/2) -> 1200 * log2(x/y)
 * 3. Cents: plain number (e.g., 702)
 */
function parseInterval(input) {
  input = input.trim();
  if(!input) return NaN;

  // 1. EDO steps format: x\y
  if (input.includes('\\')) {
    const parts = input.split('\\').map(x => parseFloat(x.trim()));
    if (parts.length === 2 && isFinite(parts[0]) && isFinite(parts[1]) && parts[1] !== 0) {
      // Cents = 1200 * log2(2^(x/y)) = 1200 * x/y
      return 1200 * (parts[0] / parts[1]); 
    }
    return NaN;
  } 
  
  // 2. Ratio format: x/y
  if (input.includes('/')){
    const [a,b] = input.split('/').map(x=>parseFloat(x.trim()));
    if(isFinite(a) && isFinite(b) && b!==0) return centsOfRatio(a/b);
    return NaN;
  } 
  
  // 3. Assume cents if no format found
  const v = parseFloat(input);
  return isFinite(v) ? v : NaN; 
}

/**
 * Converts cents to the raw number of EDO steps (before modulo N).
 * This is used for generating the scale steps, where an octave is N steps, not 0.
 */
function centsToEDOStepRaw(cents, N) {
  if (N === 0) return 0;
  // Quantize cents to the nearest EDO step (can be >= N)
  return Math.round((cents / 1200) * N);
}

function parseUDP(udpStr) {
  const match = udpStr.match(/(\d+)\|(\d+)\((\d+)\)/);
  if (!match) return null;
  return {
    up: parseInt(match[1]),
    down: parseInt(match[2]),
    periods: parseInt(match[3])
  };
}

function mod(a, b) {
  return ((a % b) + b) % b;
}

const canonicalChainOfFifths = ["Dbb", "Abb", "Ebb", "Bbb", "Fb","Cb","Gb","Db","Ab","Eb","Bb","F","C","G","D","A","E","B","F#","C#","G#","D#","A#","E#","B#", "Fx", "Cx"];
const fifthspanMap = {};
canonicalChainOfFifths.forEach((name, i) => { const span = i - canonicalChainOfFifths.indexOf("C"); fifthspanMap[name] = span; });

function generateEDONaming(N){ /* ... logic unchanged ... */
  const kfloat = N * Math.log2(3/2); const k = Math.round(kfloat); const wholeTone = (2 * k) % N; const chromaticRaw = (7 * k) - (4 * N); const chromatic = ((chromaticRaw % N) + N) % N; const diatonic = ((wholeTone - chromatic) % N + N) % N;
  const fifthOffsets = { 'C':0, 'G':1, 'D':2, 'A':3, 'E':4, 'B':5, 'F':-1 }; const letterSteps = {};
  for(const [L, offs] of Object.entries(fifthOffsets)){ let pos = (offs * k) % N; pos = (pos + N) % N; letterSteps[L] = pos; }
  function canonicalNameToStep(name){ const letter = name[0]; const rest = name.slice(1); let base = letterSteps[letter] ?? 0; for(const ch of rest){ if(ch === '#') base = (base + chromatic) % N; else if(ch === 'b') base = (base - chromatic + N) % N; } return (base + N) % N; }
  const stepToCanonicalNames = new Map();
  for(const cname of canonicalChainOfFifths){ const s = canonicalNameToStep(cname); if(!stepToCanonicalNames.has(s)) stepToCanonicalNames.set(s, []); stepToCanonicalNames.get(s).push(cname); }
  const canonicalSteps = Array.from(stepToCanonicalNames.keys());
  const names = Array.from({length:N}, ()=>[]);
  for(const [s,list] of stepToCanonicalNames.entries()) names[s] = [...new Set(list)];
  for(let s=0; s<N; s++){
    if(names[s].length > 0) continue;
    let best = null; let bestAbs = Infinity; let bestSigned = 0; let bestCanonicalStep = null;
    for(const cs of canonicalSteps){
      let signed = ((s - cs + N) % N);
      if(signed > N/2) signed -= N;
      const absd = Math.abs(signed);
      if(absd < bestAbs){ bestAbs = absd; bestSigned = signed; bestCanonicalStep = cs; }
    }
    const baseNames = stepToCanonicalNames.get(bestCanonicalStep) || ['?'];
    const prefList = baseNames.map(bn => {
      if(bestSigned > 0) return '^'.repeat(bestSigned) + bn;
      if(bestSigned < 0) return 'v'.repeat(-bestSigned) + bn;
      return bn;
    });
    names[s] = prefList;
  }
  return { names, info: {k, wholeTone, chromaticRaw, chromatic, diatonic} };
}

function pickSimplestName(list){ /* ... logic unchanged ... */
  if(!Array.isArray(list) || list.length===0) return '?';
  const uniq = Array.from(new Set(list));
  function analyze(n){
    let s = n; let prefixShift = 0;
    while(s[0] === '^' || s[0] === 'v'){ prefixShift += (s[0] === '^' ? 1 : -1); s = s.slice(1); }
    const core = s; const spanFromC = (fifthspanMap[core] ?? 0) + prefixShift; const absSpan = Math.abs(spanFromC);
    const isNatural = /^[A-G]$/.test(core); const sharps = (core.match(/#/g)||[]).length; const flats = (core.match(/b/g)||[]).length;
    const accidentalCount = sharps + flats; const kindScore = isNatural ? 0 : (sharps>0 ? 1 : (flats>0 ? 2 : 3));
    return {orig: n, absSpan, kindScore, accidentalCount, length: n.length};
  }
  const analyzed = uniq.map(s => ({s, a: analyze(s)}));
  analyzed.sort((A,B)=>{
    if(A.a.absSpan !== B.a.absSpan) return A.a.absSpan - B.a.absSpan;  
    if(A.a.kindScore !== B.a.kindScore) return A.a.kindScore - B.a.kindScore;
    if(A.a.accidentalCount !== B.a.accidentalCount) return A.a.accidentalCount - B.a.accidentalCount;
    if(A.a.length !== B.a.length) return A.a.length - B.a.length;
    return A.s.localeCompare(B.s);
  });
  return analyzed[0].s;
}

// --- STATE ---
let gridState = {
  rows: 6, cols: 12, keySize: 64,
  tuning: { type:'edo', edo:12 },
  rootFreq: 261.6256, rootName: 'C4',
  edoNameTable: null, nonoInfo: null, jiRatios: null,
  subsetPattern: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
};

// --- MODAL CONTROLS ---

function showModal() { scaleGeneratorModal.style.display = 'flex'; }
function hideModal() { scaleGeneratorModal.style.display = 'none'; }
function showModalMessage(title, message) {
    const existing = document.getElementById('temp-modal');
    if (existing) existing.remove();
    
    const modalHtml = `
      <div id="temp-modal" class="modal-overlay" style="display:flex;">
          <div class="modal-content">
              <h3>${title}</h3><p>${message}</p>
              <div class="modal-controls">
                  <button onclick="document.getElementById('temp-modal').remove()" style="background:#f00; color:white;">Close</button>
              </div>
          </div>
      </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

generateScaleBtn.addEventListener('click', () => {
    if (tuningType.value !== 'edo') {
        showModalMessage('Action Required', 'The scale generator only works when **Tuning Type** is set to **EDO**.');
        return;
    }
    showModal();
});
gen_cancelBtn.addEventListener('click', hideModal);
gen_applyBtn.addEventListener('click', () => {
    generateAndApplyScale(gen_generator.value, gen_period.value, gen_udp.value);
});


// --- SCALE GENERATOR LOGIC ---

function generateAndApplyScale(generatorStr, periodStr, udpStr) {
    const N = parseInt(edoStepsInput.value);

    if (tuningType.value !== 'edo' || !N || N < 2) {
        showModalMessage('Error', 'Please ensure Tuning Type is EDO and EDO steps (N) is a valid number (> 1).');
        return;
    }

    const generatorCents = parseInterval(generatorStr);
    const periodCents = parseInterval(periodStr);
    const udp = parseUDP(udpStr);

    if (!udp || isNaN(generatorCents) || isNaN(periodCents)) {
        showModalMessage('Error', 'Invalid input for Generator, Period, or UDP format. Please check your values.');
        return;
    }

    // Convert Cents to RAW EDO Steps (can be > N for period, e.g., 12/12 in 12-EDO is 12 steps)
    const generatorStepRaw = centsToEDOStepRaw(generatorCents, N);
    const periodStepRaw = centsToEDOStepRaw(periodCents, N);

    // Validation check for period magnitude (must be at least one step)
    if (Math.abs(periodStepRaw) < 1) {
        showModalMessage('Error', 'The Period interval cannot quantize to zero EDO steps. It must represent at least one full step.');
        return;
    }

    const pitchesEDOSteps = new Set();
    
    for (let p = 0; p < udp.periods; p++) {
        // Use the RAW step count for the period offset calculation
        const periodOffset = p * periodStepRaw; 
        for (let i = -udp.down; i <= udp.up; i++) {
            // Use the RAW step count for generator steps as well
            let step = (i * generatorStepRaw) + periodOffset; 
            
            // Modulo only at the end to get the step index (0 to N-1)
            step = mod(step, N); 
            pitchesEDOSteps.add(step);
        }
    }
    
    const finalScale = Array.from(pitchesEDOSteps).sort((a, b) => a - b);
    
    if (finalScale.length < 2) {
        showModalMessage('Error', 'The generated scale has fewer than 2 unique steps. Try different parameters.');
        return;
    }

    gridState.subsetPattern = finalScale;
    
    applySubsetPatternToUI(finalScale);

    hideModal();
    updateLegend();
    resizeCanvas();
    renderGrid();
}

// --- STATE MANAGEMENT ---

function generateFullScaleSteps(tuning, edoNameTable, jiRatios) {
  let steps = []; let N = 0; 
  if (tuning.type === 'edo') {
    N = tuning.edo;
    for (let i = 0; i < N; i++) {
      steps.push({ index: i, name: pickSimplestName(edoNameTable[i] || ['?']) });
    }
  } 
  return { steps, N };
}

function populateScaleSubsetSelect(fullSteps) {
  const select = document.getElementById('scaleSubset');
  select.innerHTML = ''; 
  if (fullSteps.length === 0) {
    select.innerHTML = '<option disabled>No steps available</option>';
    return;
  }
  for (const step of fullSteps) {
    const option = document.createElement('option');
    option.value = step.index; 
    option.textContent = `[${step.index}] ${step.name}`; 
    select.appendChild(option);
  }
}

function applySubsetPatternToUI(pattern) {
    for (const option of scaleSubsetSelect.options) { option.selected = false; }
    const patternSet = new Set(pattern.map(String)); 
    for (const option of scaleSubsetSelect.options) {
        if (patternSet.has(option.value)) {
            option.selected = true;
        }
    }
}

function getSelectedSubset() {
    const selections = [];
    for (const option of scaleSubsetSelect.options) {
      if (option.selected) {
        selections.push(parseInt(option.value, 10));
      }
    }
    const finalPattern = [...new Set([0, ...selections])].sort((a, b) => a - b);
    return finalPattern;
}

function buildStateFromUI(){
  const rows = Math.max(1, parseInt(rowsInput.value) || 6);
  const cols = Math.max(1, parseInt(colsInput.value) || 12);
  const keySize = Math.max(8, parseInt(keySizeInput.value) || 64);
  const rootFreq = Math.max(1, parseFloat(rootFreqInput.value) || 261.6256);
  const rootName = rootNoteNameInput.value || 'root';
  const type = tuningType.value;

  gridState.rows = rows; gridState.cols = cols; gridState.keySize = keySize;
  gridState.rootFreq = rootFreq; gridState.rootName = rootName;

  let totalSteps = 0; 
  let tuningTextContent = '';
  let fullStepsData = [];

  if(type === 'edo'){
    const N = Math.max(2, parseInt(edoStepsInput.value) || 12);
    gridState.tuning = { type:'edo', edo: N };
    gridState.edoNameTable = generateEDONaming(N).names;
    gridState.nonoInfo = null; gridState.jiRatios = null;
    tuningTextContent = `${N}-EDO (names generated from chain-of-fifths)`;
  } 
  // ... (nonoctave/JI logic omitted)
  
  const fullStepsResult = generateFullScaleSteps(
    gridState.tuning, 
    gridState.edoNameTable, 
    gridState.jiRatios
  );
  fullStepsData = fullStepsResult.steps;
  totalSteps = fullStepsResult.N;

  const oldSubsetLength = scaleSubsetSelect.options.length;
  const tuningChanged = totalSteps !== oldSubsetLength;

  if (tuningChanged || totalSteps === 0) {
      populateScaleSubsetSelect(fullStepsData);
      // Default to full scale selection visually
      for (const option of scaleSubsetSelect.options) { option.selected = true; }
  }
  
  gridState.subsetPattern = getSelectedSubset();

  tuningText.textContent = tuningTextContent;
  return true;
}

function frequencyForIndex(idx){
  const t = gridState.tuning; 
  const root = gridState.rootFreq;
  const subset = gridState.subsetPattern;
  if (subset.length === 0) return root; 
  const subsetIntervalIndex = idx % subset.length;
  const intervalStep = subset[subsetIntervalIndex];
  const octaveShift = Math.floor(idx / subset.length);

  if(t.type === 'edo'){
    const effectiveStep = intervalStep + (octaveShift * t.edo);
    return root * Math.pow(2, effectiveStep / t.edo);
  }
  return root;
}

function nameForIndex(idx){
  const t = gridState.tuning;
  const subset = gridState.subsetPattern;
  if (subset.length === 0) return 'Error';
  const subsetIntervalIndex = idx % subset.length;
  const intervalStep = subset[subsetIntervalIndex];
  const octaveShift = Math.floor(idx / subset.length);
  const octaveNum = Math.floor(gridState.rootName.match(/\d/)?.[0] || 4) + octaveShift;
  
  let baseName = '';
  
  if(t.type === 'edo'){
    const step = ((intervalStep % t.edo)+t.edo)%t.edo;
    const candidates = gridState.edoNameTable[step] || [];
    baseName = pickSimplestName(candidates);
  }
  
  if (t.type === 'edo') {
      return `${baseName.replace(/\d/g, '')}${octaveNum}`;
  }
  return baseName;
}


// --- CANVAS DRAWING & INTERACTION ---

function resizeCanvas(){
  const ks = gridState.keySize;
  const width = gridState.cols * ks;
  const height = gridState.rows * ks;
  canvas.width = width; canvas.height = height;
  
  // Set canvas size based on its container (for responsiveness)
  const wrapper = document.getElementById('gridWrap');
  if (wrapper) {
      // Set the explicit size on the canvas element, but let CSS handle the visual scaling
      canvas.style.maxWidth = '100%';
      canvas.style.height = 'auto'; 
  }
}

function renderGrid(){
  const ks = gridState.keySize, rows = gridState.rows, cols = gridState.cols;
  ctx.fillStyle='var(--key-color)'; 
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle='rgba(0,0,0,0.2)'; 
  ctx.lineWidth=1;
  ctx.font = Math.max(10, Math.floor(ks/5)) + 'px system-ui, sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x=c*ks, y=r*ks; 
      const idx=r*cols+c; 
      
      // Highlight active key
      ctx.fillStyle = activeVoices.has(idx) ? '#ffcc00' : 'rgba(255,255,255,0.9)';
      ctx.fillRect(x,y,ks,ks); 
      
      // Draw border
      ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);
      
      // Draw text
      let label = nameForIndex(idx);
      ctx.fillStyle='#111'; 
      let disp=String(label); 
      if(disp.length>14) disp = disp.slice(0,12)+'…';
      ctx.fillText(disp, x+ks/2, y+ks/2);
    }
  }
}

function drawKeyActive(idx, isActive) {
  const ks = gridState.keySize;
  const c = idx % gridState.cols;
  const r = Math.floor(idx / gridState.cols);
  const x = c * ks;
  const y = r * ks;
  
  // Redraw the key to reflect the active state
  ctx.fillStyle = isActive ? '#ffcc00' : 'rgba(255,255,255,0.9)';
  ctx.fillRect(x,y,ks,ks);
  
  ctx.strokeStyle='rgba(0,0,0,0.2)';
  ctx.lineWidth=1;
  ctx.strokeRect(x+0.5,y+0.5,ks-1,ks-1);

  // Redraw text
  let label = nameForIndex(idx);
  ctx.fillStyle='#111'; 
  let disp=String(label); 
  if(disp.length>14) disp = disp.slice(0,12)+'…';
  ctx.fillText(disp, x+ks/2, y+ks/2);
}


function noteOn(idx){
  if(activeVoices.has(idx)) return;
  
  if (audioCtx.state === 'suspended') { audioCtx.resume(); }

  const freq = frequencyForIndex(idx);
  const wave = waveSel.value;
  const release = parseFloat(releaseInput.value) || 120;

  const voice = new Synth(audioCtx, masterGain, wave, release);
  activeVoices.set(idx, voice);
  voice.start(freq);
  
  drawKeyActive(idx, true);
}

function noteOff(idx){
  const voice = activeVoices.get(idx);
  if(!voice) return;

  if (sustainToggle.checked) {
    // If sustain is on, we keep the voice active in the map, 
    // but visually show the key is no longer being pressed.
    drawKeyActive(idx, false);
    // Voice stays alive until stopAll is called or key is released
  } else {
    // If sustain is off, release the voice immediately
    voice.release();
    activeVoices.delete(idx);
    drawKeyActive(idx, false);
  }
}

function stopAllVoices() {
    activeVoices.forEach((voice, idx) => {
        voice.release(); // Releases all voices
        drawKeyActive(idx, false);
    });
    activeVoices.clear();
}


function canvasPosToIndex(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  const col = Math.floor(x / gridState.keySize);
  const row = Math.floor(y / gridState.keySize);
  
  if (row >= 0 && row < gridState.rows && col >= 0 && col < gridState.cols) {
    return row * gridState.cols + col;
  }
  return -1;
}

function pointerdown(e) {
  e.preventDefault();
  const idx = canvasPosToIndex(e);
  if(idx !== -1) {
    pointerToIdx.set(e.pointerId, idx);
    noteOn(idx);
  }
}

function pointerup(e) {
  e.preventDefault();
  const idx = pointerToIdx.get(e.pointerId);
  if(idx !== undefined) {
    noteOff(idx);
    pointerToIdx.delete(e.pointerId);
  }
}

// Attach pointer events to the canvas
canvas.addEventListener('pointerdown', pointerdown);
canvas.addEventListener('pointerup', pointerup);
canvas.addEventListener('pointercancel', pointerup);


// --- BUTTON HANDLERS AND INIT ---

applyBtn.addEventListener('click', () => {
  const ok = buildStateFromUI(); if(!ok) return;
  resizeCanvas(); renderGrid(); updateLegend();
});

stopAllBtn.addEventListener('click', stopAllVoices);

tuningType.addEventListener('change', () => {
  const v = tuningType.value;
  edoParams.style.display = v === 'edo' ? '' : 'none';
  nonoParams.style.display = v === 'nonoctave' ? '' : 'none';
  jiParams.style.display = v === 'ji' ? '' : 'none';
  // Re-build state to refresh the dropdown and grid when tuning type changes
  buildStateFromUI();
  resizeCanvas();
  renderGrid();
  updateLegend();
});

function updateLegend(){
  const t = gridState.tuning;
  const subsetSize = gridState.subsetPattern.length;
  let txt = `Grid: ${gridState.rows}×${gridState.cols} (Scale size: ${subsetSize}) • Key size: ${gridState.keySize}px • Root: ${gridState.rootName} @ ${gridState.rootFreq} Hz. `;
  
  if(t.type === 'edo') txt += `${t.edo}-EDO underlying. `;
  // ... (nonoctave/JI logic omitted)

  txt += `Scale steps (EDO indexes): [${gridState.subsetPattern.join(', ')}]`;
  notesLegend.textContent = txt;
}

/* init */
buildStateFromUI();
resizeCanvas();
renderGrid();
updateLegend();

window.addEventListener('resize', () => { resizeCanvas(); renderGrid(); });

</script>
</body>
</html>