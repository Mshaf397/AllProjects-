<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
 <title>Grid Synth (extended)</title>
 <style>
 :root {
  --key-min-width: 60px;
  --key-height: 60px;
 }
 body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 1em; }
 .controls { display:flex; flex-wrap:wrap; gap:1rem; align-items:center; margin-bottom:0.75rem; }
 .controls label { display:flex; flex-direction:column; font-size:0.85rem; min-width:120px; }
 .controls input, .controls select, .controls button, .controls textarea {
 padding: 8px;
 font-size: 0.95rem;
 margin-top:6px;
 }
 .grid-wrapper {
 width: 100%;
 height: 70vh;
 overflow: auto;
 border: 1px solid #ccc;
 position: relative;
 cursor: grab;
 background: linear-gradient(180deg, rgba(0,0,0,0.01), rgba(0,0,0,0.02));
 border-radius: 6px;
 }
 .grid {
 display: grid;
 gap: 6px;
 user-select: none;
 padding: 8px;
 box-sizing: border-box;
 align-items: stretch;
 }
 .key {
 font-size: 0.85rem;
 padding: 6px;
 min-width: var(--key-min-width);
 height: var(--key-height);
 display:flex;
 flex-direction:column;
 justify-content:center;
 align-items:center;
 background: white;
 border-radius: 6px;
 border: 1px solid #e2e2e2;
 box-shadow: 0 1px 0 rgba(0,0,0,0.02);
 text-align:center;
 line-height:1;
 }
    .key:hover { background:#f6f6f6; cursor:pointer; }
    .key .name { font-weight:600; font-size:0.9rem; margin-bottom:4px; }
    .key .freq { font-size:0.8rem; color:#333; }
    .key .cents { font-size:0.7rem; color:#666; margin-top:3px; }
    .small { font-size:0.8rem; color:#666; }
    .controls-row { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; }
    textarea { min-height:64px; resize:vertical; }
  </style>
</head>
<body>

<div class="controls">
  <div style="min-width:220px;">
    <label>Rows: <input type="number" id="rows" value="8" min="1"></label>
    <label>Columns: <input type="number" id="cols" value="12" min="1"></label>
  </div>

  <div>
    <label>Root Key Index (grid index): <input type="number" id="rootKey" value="24" min="0"></label>
    <label>Root Frequency (Hz): <input type="number" id="rootHz" value="440" step="0.01"></label>
    <label>or Root MIDI: <input type="number" id="rootMidi" value="69"></label>
  </div>

  <div>
    <label>Tuning:
      <select id="tuningType">
        <option value="edo">Equal-step (edo)</option>
        <option value="ji">Just Intonation (JI)</option>
        <option value="nonoctave">Non-octave (xedY)</option>
      </select>
    </label>
    <span id="edoControls">
      <label>Steps per Octave: <input type="number" id="steps" value="12" min="1"></label>
    </span>
    <span id="jiControls" style="display:none;">
      <label>Prime Limit: <input type="number" id="primeLimit" value="7" min="2"></label>
    </span>
    <span id="nonoctaveControls" style="display:none;">
      <label>Steps (x): <input type="number" id="nonoctaveSteps" value="7" min="1"></label>
      <label>Ratio (Y, e.g. 3/2 or 1.5): <input type="text" id="nonoctaveRatio" value="3/2"></label>
    </span>
  </div>

  <div>
    <label>Waveform:
      <select id="waveform">
        <option>sine</option>
        <option>square</option>
        <option>triangle</option>
        <option>sawtooth</option>
      </select>
    </label>

    <label>Key Width (px): <input type="number" id="keyWidth" value="90" min="20"></label>
    <label>Key Height (px): <input type="number" id="keyHeight" value="70" min="20"></label>
  </div>

  <div style="display:flex; flex-direction:column; gap:8px;">
    <div class="controls-row">
      <button onclick="renderKeyboard()">Render</button>
      <button onclick="randomizeRoot()">Random root</button>
      <button onclick="stopAll()">Stop all</button>
    </div>
    <div class="small">Tip: drag inside the grid to pan. Pointer/touch friendly.</div>
  </div>
</div>

<div class="grid-wrapper" id="wrapper">
  <div id="keyboard" class="grid"></div>
</div>

<script>
  const wrapper = document.getElementById("wrapper");
  const keyboard = document.getElementById("keyboard");
  const tuningTypeSel = document.getElementById("tuningType");
  const edoControls = document.getElementById("edoControls");
  const jiControls = document.getElementById("jiControls");
  const nonoctaveControls = document.getElementById("nonoctaveControls");

  // Drag scrolling (pointer-friendly)
  let isDragging = false, startX = 0, startY = 0, scrollLeft = 0, scrollTop = 0;
  function startDrag(e) {
    isDragging = true;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    startX = clientX;
    startY = clientY;
    scrollLeft = wrapper.scrollLeft;
    scrollTop = wrapper.scrollTop;
    wrapper.style.cursor = "grabbing";
  }
  function dragMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const dx = clientX - startX;
    const dy = clientY - startY;
    wrapper.scrollLeft = scrollLeft - dx;
    wrapper.scrollTop = scrollTop - dy;
  }
  function endDrag() {
    isDragging = false;
    wrapper.style.cursor = "grab";
  }
  wrapper.addEventListener("pointerdown", startDrag);
  wrapper.addEventListener("pointermove", dragMove);
  wrapper.addEventListener("pointerup", endDrag);
  wrapper.addEventListener("pointercancel", endDrag);
  wrapper.addEventListener("pointerleave", endDrag);

  tuningTypeSel.addEventListener("change", () => {
    const type = tuningTypeSel.value;
    edoControls.style.display = type === "edo" ? "inline" : "none";
    jiControls.style.display = type === "ji" ? "inline" : "none";
    nonoctaveControls.style.display = type === "nonoctave" ? "inline" : "none";
  });

  // Audio context
  let audioCtx = null;
  // Keep track of active nodes so we can stop them all
  const activeNodes = new Set();

  // Helpers
  function midiToHz(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
  }
  function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
  }
  function getPrimeFactors(n) {
    const factors = new Set();
    let x = n;
    for (let i = 2; i <= x; i++) {
      while (x % i === 0) {
        factors.add(i);
        x /= i;
      }
    }
    return factors;
  }
  function isJIWithinPrimeLimit([num, den], limit) {
    const primes = new Set([...getPrimeFactors(num), ...getPrimeFactors(den)]);
    return [...primes].every(p => p <= limit);
  }
  function generateJITuning(limit, maxRatio = 2, maxNumDen = 64) {
    const ratios = [];
    for (let num = 1; num <= maxNumDen; num++) {
      for (let den = 1; den <= maxNumDen; den++) {
        const val = num / den;
        if (val < 1 / maxRatio || val > maxRatio) continue;
        if (gcd(num, den) !== 1) continue;
        if (isJIWithinPrimeLimit([num, den], limit)) {
          ratios.push([num, den]);
        }
      }
    }
    return ratios.sort((a, b) => Math.log2(a[0]/a[1]) - Math.log2(b[0]/b[1]));
  }

  // Parse ratio string like "3/2" or "1.5"
  function parseRatio(str) {
    if (!str) return NaN;
    str = str.trim();
    if (str.includes("/")) {
      const parts = str.split("/").map(s => s.trim());
      const num = parseFloat(parts[0]);
      const den = parseFloat(parts[1] || 1);
      if (isFinite(num) && isFinite(den) && den !== 0) return num / den;
      return NaN;
    } else {
      const val = parseFloat(str);
      return isFinite(val) ? val : NaN;
    }
  }

  // Stop all playing nodes
  function stopAll() {
    for (const node of Array.from(activeNodes)) {
      try {
        node.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
        node.gainNode.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.01);
        // schedule stop in short while
        node.osc.stop(audioCtx.currentTime + 0.03);
      } catch (e) { /* ignore */ }
      activeNodes.delete(node);
    }
  }

  function randomizeRoot() {
    const rows = parseInt(document.getElementById("rows").value);
    const cols = parseInt(document.getElementById("cols").value);
    const num = rows * cols;
    const r = Math.floor(Math.random() * num);
    document.getElementById("rootKey").value = r;
    renderKeyboard();
  }

  // Render keyboard
  function renderKeyboard() {
    // stop any playing
    stopAll();

    const rows = parseInt(document.getElementById("rows").value) || 1;
    const cols = parseInt(document.getElementById("cols").value) || 1;
    const numKeys = rows * cols;
    const rootIndex = parseInt(document.getElementById("rootKey").value) || 0;

    // key sizing
    const keyW = Math.max(20, parseInt(document.getElementById("keyWidth").value) || 60);
    const keyH = Math.max(20, parseInt(document.getElementById("keyHeight").value) || 60);
    document.documentElement.style.setProperty('--key-min-width', `${keyW}px`);
    document.documentElement.style.setProperty('--key-height', `${keyH}px`);

    const hzInput = parseFloat(document.getElementById("rootHz").value);
    const midiInput = parseInt(document.getElementById("rootMidi").value);
    const rootFreq = (!isNaN(hzInput) && hzInput > 0) ? hzInput : midiToHz(isFinite(midiInput) ? midiInput : 69);

    const tuningType = document.getElementById("tuningType").value;

    keyboard.innerHTML = "";
    keyboard.style.gridTemplateColumns = `repeat(${cols}, ${keyW}px)`;
    keyboard.style.gridAutoRows = `${keyH}px`;

    // build frequencies array according to chosen tuning
    let frequencies = [];

    if (tuningType === "edo") {
      const edoSteps = Math.max(1, parseInt(document.getElementById("steps").value) || 12);
      for (let i = 0; i < numKeys; i++) {
        const stepsFromRoot = i - rootIndex;
        const freq = rootFreq * Math.pow(2, stepsFromRoot / edoSteps);
        frequencies.push(freq);
      }
    } else if (tuningType === "ji") {
      const primeLimit = Math.max(2, parseInt(document.getElementById("primeLimit").value) || 7);
      const ratios = generateJITuning(primeLimit, 2, 80);
      if (ratios.length === 0) {
        // fallback to 12-edo if nothing generated
        for (let i = 0; i < numKeys; i++) {
          const stepsFromRoot = i - rootIndex;
          const freq = rootFreq * Math.pow(2, stepsFromRoot / 12);
          frequencies.push(freq);
        }
      } else {
        // center around rootIndex: place ratios cyclically but allow indexing offset so rootIndex corresponds to ratio = 1/1
        // find index of ratio 1/1 if present
        let baseIdx = ratios.findIndex(r => r[0] === 1 && r[1] === 1);
        if (baseIdx === -1) baseIdx = 0;
        for (let i = 0; i < numKeys; i++) {
          const idx = (baseIdx + (i - rootIndex)) % ratios.length;
          const wrapIdx = (idx + ratios.length) % ratios.length;
          const [num, den] = ratios[wrapIdx];
          frequencies.push(rootFreq * (num / den));
        }
      }
    } else if (tuningType === "nonoctave") {
      const x = Math.max(1, parseInt(document.getElementById("nonoctaveSteps").value) || 7);
      const ratioStr = document.getElementById("nonoctaveRatio").value || "3/2";
      const Y = parseRatio(ratioStr);
      if (!isFinite(Y) || Y <= 0) {
        alert("Invalid non-octave ratio Y. Please enter something like 3/2 or 1.5");
        return;
      }
      const stepFactor = Math.pow(Y, 1 / x); // frequency multiplier per step
      for (let i = 0; i < numKeys; i++) {
        const stepsFromRoot = i - rootIndex;
        const freq = rootFreq * Math.pow(stepFactor, stepsFromRoot);
        frequencies.push(freq);
      }
    }

    const waveform = document.getElementById("waveform").value || "sine";

    // create keys
    frequencies.forEach((freq, i) => {
      const div = document.createElement("div");
      div.className = "key";
      // label: freq, cents relative to root
      const cents = (1200 * Math.log2(freq / rootFreq)).toFixed(2);
      div.innerHTML = `
        <div class="freq">${freq.toFixed(3)} Hz</div>
        <div class="cents">${cents}¢</div>
      `;

      // pointer play logic
      let osc = null;
      let gainNode = null;
      let playing = false;

      function startNote(e) {
        e.preventDefault();
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // ensure context resumed on first user gesture
        if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }
        if (playing) return;
        osc = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        osc.type = waveform;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.0001, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.6, audioCtx.currentTime + 0.01);
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        osc.start();
        playing = true;
        activeNodes.add({ osc, gainNode });
      }

      function stopNote() {
        if (!playing || !osc || !gainNode) return;
        try {
          gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
          gainNode.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.015);
          osc.stop(audioCtx.currentTime + 0.03);
        } catch (e) {}
        // remove reference from active set (find by osc)
        for (const node of Array.from(activeNodes)) {
          if (node.osc === osc) activeNodes.delete(node);
        }
        playing = false;
        osc = null;
        gainNode = null;
      }

      // Use pointer events to handle mouse/touch uniformly
      div.addEventListener("pointerdown", startNote);
      // we want note to sustain while pointer is down; pointerup and pointercancel stop it
      div.addEventListener("pointerup", stopNote);
      div.addEventListener("pointerleave", (ev) => {
        // if pointer is pressed and leaves, also stop
        if (ev.pressure > 0 || ev.buttons) stopNote();
      });
      div.addEventListener("pointercancel", stopNote);
      // double-click to play one second preview using separate node
      div.addEventListener("dblclick", (ev) => {
        ev.preventDefault();
        const tmpCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = tmpCtx;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = waveform;
        o.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.6, audioCtx.currentTime + 0.01);
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 1.0);
      });

      keyboard.appendChild(div);
    });
  }

  // small helper for safety (escape name text)
  function escapeHtml(unsafe) {
    return unsafe.replace(/[&<"'>]/g, function (m) {
      return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' })[m];
    });
  }

  // Initial load
  renderKeyboard();

  // ensure stopAll on page hide
  window.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAll();
  });
  window.addEventListener("pagehide", stopAll);
</script>

</body>
</html>