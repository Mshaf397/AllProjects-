<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Microtonal Song Generator</title>
<style>
  :root {
    --bg: #0b0f14;
    --panel: #121821;
    --text: #e8eef7;
    --muted: #a7b3c4;
    --accent: #64b5f6;
    --bad: #ef9a9a;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: var(--bg); color: var(--text); line-height: 1.45;
  }
  header { padding: 20px; border-bottom: 1px solid #1f2a37; background: #0d1219; }
  header h1 { margin: 0 0 6px 0; font-size: 20px; }
  header p { margin: 0; color: var(--muted); font-size: 13px; }
  main { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
  @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
  .card { background: var(--panel); border: 1px solid #1f2a37; border-radius: 10px; padding: 14px; }
  .card h2 { margin: 0 0 12px 0; font-size: 16px; color: var(--accent); }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
  label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
  input[type="number"], select {
    width: 100%; background: #0c1118; border: 1px solid #1f2a37; color: var(--text);
    border-radius: 8px; padding: 8px 10px; font-size: 14px;
  }
  .inline { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
  .inline > div { flex: 1 1 110px; }
  fieldset { border: 1px dashed #263241; border-radius: 8px; padding: 10px; margin: 10px 0 0 0; }
  fieldset legend { color: var(--muted); font-size: 12px; padding: 0 6px; }
  .btns { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
  button {
    background: #122337; color: var(--text); border: 1px solid #23405f; border-radius: 8px;
    padding: 8px 12px; cursor: pointer; font-weight: 600;
  }
  button.primary { background: #1d3a5a; border-color: #2b5c8d; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .out {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background: #0b1016; border: 1px solid #1f2a37; border-radius: 8px; padding: 10px;
    overflow: auto; white-space: pre; max-height: 60vh;
  }
  .mini { font-size: 12px; color: var(--muted); }
  .pill { display: inline-block; padding: 3px 8px; border: 1px solid #2d3a4b; border-radius: 999px; font-size: 12px; color: var(--muted); }
</style>
</head>
<body>
<header>
  <h1>Microtonal Song Generator</h1>
  <p>EDO up to 1200 with fifth-chain ups/downs spelling, JI up to 997-limit; custom meters, durations 1 → 0.03125, fitting chords.</p>
</header>

<main>
  <section class="card">
    <h2>Configuration</h2>

    <div class="row">
      <div>
        <label for="mode">Tuning mode</label>
        <select id="mode">
          <option value="edo">EDO (equal divisions of the octave)</option>
          <option value="ji">JI (just intonation)</option>
        </select>
      </div>
      <div>
        <label for="seed">Random seed (optional)</label>
        <input id="seed" type="number" placeholder="e.g., 12345" />
      </div>
    </div>

    <fieldset>
      <legend>EDO settings</legend>
      <div class="row">
        <div>
          <label for="edoN">Divisions (2–1200)</label>
          <input id="edoN" type="number" min="2" max="1200" value="31" />
        </div>
        <div>
          <label for="scaleLen">Scale length (steps per octave)</label>
          <input id="scaleLen" type="number" min="3" max="24" value="7" />
        </div>
      </div>
    </fieldset>

    <fieldset>
      <legend>JI settings</legend>
      <div class="row">
        <div>
          <label for="jiPrime">Prime limit (<= 997)</label>
          <input id="jiPrime" type="number" min="3" max="997" value="13" />
        </div>
        <div>
          <label for="jiSpan">Max numerator/denominator</label>
          <input id="jiSpan" type="number" min="16" max="8192" value="1024" />
        </div>
      </div>
    </fieldset>

    <fieldset>
      <legend>Rhythm and form</legend>
      <div class="inline">
        <div>
          <label for="tsNum">Time signature numerator</label>
          <input id="tsNum" type="number" min="1" max="32" value="4" />
        </div>
        <div>
          <label for="tsDen">Time signature denominator</label>
          <input id="tsDen" type="number" min="1" max="64" value="4" />
        </div>
        <div>
          <label for="measures">Measures</label>
          <input id="measures" type="number" min="1" max="64" value="8" />
        </div>
      </div>
      <div class="mini" style="margin-top:6px;">Allowed durations are whole-note units: 1, 0.5, 0.25, 0.125, 0.0625, 0.03125</div>
      <div class="inline" style="margin-top:8px; gap:6px;">
        <label>Durations</label>
        <span class="pill"><input type="checkbox" class="dur" value="1" checked> 1</span>
        <span class="pill"><input type="checkbox" class="dur" value="0.5" checked> 0.5</span>
        <span class="pill"><input type="checkbox" class="dur" value="0.25" checked> 0.25</span>
        <span class="pill"><input type="checkbox" class="dur" value="0.125" checked> 0.125</span>
        <span class="pill"><input type="checkbox" class="dur" value="0.0625" checked> 0.0625</span>
        <span class="pill"><input type="checkbox" class="dur" value="0.03125" checked> 0.03125</span>
      </div>
    </fieldset>

    <fieldset>
      <legend>Melody and harmony</legend>
      <div class="row-3">
        <div>
          <label for="rangeOct">Melody range (octaves)</label>
          <input id="rangeOct" type="number" min="1" max="4" value="1" />
        </div>
        <div>
          <label for="stepBias">Melodic step bias (0–1)</label>
          <input id="stepBias" type="number" step="0.05" min="0" max="1" value="0.7" />
        </div>
        <div>
          <label for="chordDensity">Chord density (0–1)</label>
          <input id="chordDensity" type="number" step="0.1" min="0" max="1" value="1.0" />
        </div>
      </div>
      <div class="row-3" style="margin-top:8px;">
        <div>
          <label for="chordSize">Chord size</label>
          <input id="chordSize" type="number" min="3" max="6" value="3" />
        </div>
        <div>
          <label for="bpm">Tempo (BPM)</label>
          <input id="bpm" type="number" min="30" max="240" value="96" />
        </div>
        <div>
          <label for="transpose">Playback semitone transpose</label>
          <input id="transpose" type="number" step="1" min="-48" max="48" value="0" />
        </div>
      </div>
    </fieldset>

    <div class="btns">
      <button class="primary" id="gen">Generate</button>
      <button id="play" disabled>Play</button>
      <button id="stop" disabled>Stop</button>
      <button id="copy" disabled>Copy text</button>
    </div>
    <div id="err" class="mini" style="color: var(--bad); margin-top:8px;"></div>
  </section>

  <section class="card">
    <h2>Output</h2>
    <div class="row">
      <div>
        <div class="mini">Summary</div>
        <div id="summary" class="out"></div>
      </div>
      <div>
        <div class="mini">Measures</div>
        <div id="measuresOut" class="out"></div>
      </div>
    </div>
    <div class="mini" style="margin-top:8px;">
      EDO names follow your fifth-chain spelling with ^/v before the note. JI shows reduced ratios. C4 = 261.625 Hz.
    </div>
  </section>
</main>

<script>
/* ======== Utilities ======== */
function seededRng(seed) {
  if (seed == null || isNaN(seed)) return Math.random;
  let s = BigInt(seed) & ((1n<<63n)-1n);
  return function() {
    s = (6364136223846793005n * s + 1442695040888963407n) & ((1n<<63n)-1n);
    return Number(s) / Number((1n<<63n)-1n);
  };
}
function choice(rng, arr) { return arr[Math.floor(rng()*arr.length)] }
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t;} return a;}
function reduceRatio(n, d) { const g=gcd(n,d)||1; n/=g; d/=g; if(d<0){ n=-n; d=-d; } return [n,d]; }
function toRatioString(n,d){ const [rn,rd]=reduceRatio(n,d); return rn + "/" + rd; }
function log2(x){ return Math.log(x)/Math.log(2); }

/* ======== Fifth-chain spelling (EDO) ======== */
const FIFTH_CHAIN = [
  "Dbb","Abb","Ebb","Bbb","Fb","Cb","Gb","Db","Ab","Eb","Bb","F",
  "C","G","D","A","E","B","F#","C#","G#","D#","A#","E#","B#","Fx","Cx"
];
function bestFifthSteps(N){
  // steps ≈ round(701.955 cents / (1200/N)) = round(701.955 * N / 1200)
  return Math.round(701.955 * N / 1200);
}
function buildEdoNameMap(N){
  const k = bestFifthSteps(N);
  // anchor C at chain index of "C"
  const idxC = FIFTH_CHAIN.indexOf("C");
  const nameForStep = new Array(N).fill(null);
  const meta = new Array(N).fill(null); // store fifthspan for tie-breaking
  // walk all entries, compute step from C via fifthspan j
  for (let j = -idxC; j < FIFTH_CHAIN.length - idxC; j++){
    const chainIndex = idxC + j;
    if (chainIndex < 0 || chainIndex >= FIFTH_CHAIN.length) continue;
    const name = FIFTH_CHAIN[chainIndex];
    const step = ((j * k) % N + N) % N; // single-octave wrap
    if (nameForStep[step] == null){
      nameForStep[step] = name;
      meta[step] = j;
    } else {
      // collision: keep smallest absolute fifthspan, prefer negative if tie
      const prevJ = meta[step];
      const better =
        Math.abs(j) < Math.abs(prevJ) ||
        (Math.abs(j) === Math.abs(prevJ) && j < prevJ);
      if (better){
        nameForStep[step] = name;
        meta[step] = j;
      }
    }
  }
  // Fill unlabeled using nearest labeled with ^/v before the base name
  for (let s=0; s<N; s++){
    if (nameForStep[s] != null) continue;
    // search outward for nearest labeled; prefer downward (v) on ties
    let offset = null, baseStep = null;
    for (let r=1; r<N; r++){
      const up = (s - r + N) % N;    // down r steps from s to labeled base, needing ^ repeated r
      const dn = (s + r) % N;        // up r steps from s to labeled base, needing v repeated r
      if (nameForStep[up] != null){ offset = r; baseStep = up; break; }
      if (nameForStep[dn] != null){ offset = -r; baseStep = dn; break; }
    }
    if (baseStep == null){
      // degenerate (shouldn't happen), label as ^...C
      nameForStep[s] = "^".repeat(1) + "C";
      continue;
    }
    const base = nameForStep[baseStep];
    if (offset > 0){
      // base is below; need ^ repeated offset
      nameForStep[s] = "^".repeat(offset) + base;
    } else {
      // base is above; need v repeated -offset
      nameForStep[s] = "v".repeat(-offset) + base;
    }
  }
  return { nameForStep, fifthSize: k };
}

/* ======== Scales ======== */
function buildEdoScale(N, length, rng) {
  if (length <= 1) return [0];
  const steps = new Set([0]);
  // blue-noise-ish spacing
  const phi = (1 + Math.sqrt(5)) / 2;
  let x = 0;
  for (let i=1;i<length;i++){
    x = (x + phi) % 1;
    steps.add(Math.round(x * N) % N);
  }
  while (steps.size < length) {
    let best = null, bestGap=-1;
    for (let s=0;s<N;s++){
      if (steps.has(s)) continue;
      let mind = N;
      for (const t of steps){
        const d = Math.min((s - t + N) % N, (t - s + N) % N);
        if (d < mind) mind = d;
      }
      if (mind > bestGap){ bestGap = mind; best = s; }
    }
    steps.add(best);
  }
  return [...steps].sort((a,b)=>a-b);
}

/* ======== JI helpers ======== */
function primesUpTo(n){
  const sieve = Array(n+1).fill(true); sieve[0]=sieve[1]=false;
  for(let p=2;p*p<=n;p++) if(sieve[p]) for(let k=p*p;k<=n;k+=p) sieve[k]=false;
  return [...Array(n+1).keys()].filter(i=>sieve[i]);
}
function randomJiRatio(primeLimit, maxSpan, rng){
  const ps = primesUpTo(primeLimit);
  if (ps[0] !== 2) ps.unshift(2);
  let num=1n, den=1n;
  const useCount = Math.max(2, Math.min(6, Math.floor(rng()*ps.length)));
  const used = new Set();
  for (let i=0;i<useCount;i++){
    let p;
    for (let tries=0; tries<10; tries++){
      p = ps[Math.floor(rng()*ps.length)];
      if (!used.has(p)) break;
    }
    used.add(p);
    const r = rng();
    let e = r < 0.6 ? 0 : r < 0.75 ? 1 : r < 0.9 ? -1 : (rng()<0.5?2:-2);
    if (p === 2) e = 0;
    if (e > 0) num *= BigInt(p) ** BigInt(e);
    if (e < 0) den *= BigInt(p) ** BigInt(-e);
  }
  const lim = BigInt(maxSpan);
  num = num > lim ? lim : num;
  den = den > lim ? lim : den;
  const G=(a,b)=>b?G(b,a%b):a;
  const g = G(num,den); num/=g; den/=g;
  // normalize to [1,2)
  let r = Number(num)/Number(den);
  if (!isFinite(r) || r <= 0) return [1,1];
  while (r >= 2){ den *= 2n; r/=2; }
  while (r < 1){ num *= 2n; r*=2; }
  // approximate by continued fractions
  function approxFrac(x, maxQ){
    let h1=1, k1=0, h=0, k=1, b=x;
    while (true){
      const a = Math.floor(b);
      const t=h; h=a*h+h1; h1=t;
      const t2=k; k=a*k+k1; k1=t2;
      if (k > maxQ) break;
      const frac = h/k;
      if (Math.abs(frac - x) < 1e-12) break;
      b = 1/(b - a);
      if (!isFinite(b)) break;
    }
    if (k > maxQ){ h=h1; k=k1; }
    return [h,k];
  }
  const [rn, rd] = approxFrac(Number(num)/Number(den), maxSpan);
  return reduceRatio(rn, rd);
}

/* ======== Rhythm, melody, harmony ======== */
function fillDurations(measureLen, allowed, rng, maxTries=200){
  const toTicks = v => Math.round(v * 128);
  const fromTicks = t => t / 128;
  const target = toTicks(measureLen);
  const pool = allowed.map(toTicks).sort((a,b)=>b-a);
  for (let t=0; t<maxTries; t++){
    let rem = target;
    const out = [];
    while (rem > 0){
      const candidates = pool.filter(x => x <= rem);
      if (!candidates.length) break;
      const pick = choice(rng, candidates.slice(0, Math.max(1, Math.floor(candidates.length*(0.5+0.5*rng())))));
      out.push(pick);
      rem -= pick;
    }
    if (rem === 0) return out.map(fromTicks);
  }
  return null;
}
function randomWalkIndices(len, stepBias, rng){
  const idxs = [0];
  for (let i=1;i<len;i++){
    const r = rng();
    const step = r < stepBias ? (rng()<0.5? -1 : 1) : (rng()<0.5? -2 : 2);
    idxs.push(idxs[idxs.length-1] + step);
  }
  return idxs;
}
function edoChordForMelody(stepInOct, N, size){
  const M3 = Math.round(N*log2(5/4));
  const m3 = Math.round(N*log2(6/5));
  const P5 = Math.round(N*log2(3/2));
  const templates = [
    [0, M3, P5], // major-like
    [0, m3, P5], // minor-like
  ];
  for (const T of templates){
    for (let i=0;i<T.length;i++){
      const root = (stepInOct - T[i] + 10000*N) % N;
      const chord = T.map(x => (root + x) % N);
      if (chord.includes(stepInOct)){
        if (size > 3){
          const dom7 = Math.round(N*log2(7/4)) % N;
          chord.push((root + dom7) % N);
        }
        return [...new Set(chord)].slice(0, size).sort((a,b)=>a-b);
      }
    }
  }
  const chord = [stepInOct, (stepInOct + P5)%N, (stepInOct + N - P5)%N];
  return [...new Set(chord)].slice(0,size).sort((a,b)=>a-b);
}
function jiChordForMelody(ratioND, size){
  const [mn, md] = ratioND;
  const TEMPLATES = [
    [[1,1],[5,4],[3,2]],
    [[1,1],[6,5],[3,2]],
    [[1,1],[5,4],[15,8]],
  ];
  const mul=(a,b)=> reduceRatio(a[0]*b[0], a[1]*b[1]);
  const norm=(r)=>{ let [n,d]=r; let v=n/d; while(v>=2){ d*=2; v/=2; } while(v<1){ n*=2; v*=2; } return reduceRatio(n,d); };
  const melNorm = norm([mn,md]); const melStr = toRatioString(...melNorm);
  for (const T of TEMPLATES){
    for (let i=0;i<T.length;i++){
      const k = reduceRatio(mn*T[i][1], md*T[i][0]);
      let chord = T.map(x => norm(mul(k,x)));
      if (!chord.map(r=>toRatioString(...r)).includes(melStr)) continue;
      if (size > chord.length) chord.push(norm(mul(k,[7,4])));
      return chord.slice(0,size);
    }
  }
  const fifth=[3,2], inv=[2,3];
  return [melNorm, norm(mul(melNorm,fifth)), norm(mul(melNorm,inv))].slice(0,size);
}

/* ======== Synthesis ======== */
class Synth {
  constructor(context){ this.ctx=context; this.master=this.ctx.createGain(); this.master.gain.value=0.2; this.master.connect(this.ctx.destination); this.nodes=[]; }
  note(freq, start, dur, type='sine'){
    const osc=this.ctx.createOscillator(); const gain=this.ctx.createGain();
    osc.type=type; osc.frequency.setValueAtTime(freq, start);
    const a=0.005, d=0.03, s=0.7, r=0.05;
    gain.gain.setValueAtTime(0.0001, start);
    gain.gain.exponentialRampToValueAtTime(1.0, start+a);
    gain.gain.exponentialRampToValueAtTime(s, start+a+d);
    gain.gain.exponentialRampToValueAtTime(0.0001, start+dur+r);
    osc.connect(gain).connect(this.master);
    osc.start(start); osc.stop(start+dur+r+0.02);
    this.nodes.push(osc,gain);
  }
  stopAll(){
    try { this.nodes.forEach(n => { if (n.stop) n.stop(0); if (n.disconnect) n.disconnect(); }); } catch(e){}
    this.nodes=[];
  }
}

/* ======== Generator ======== */
function generate(config){
  const rng = seededRng(config.seed);
  const measureLen = config.tsNum / config.tsDen;
  const allowed = config.allowedDurations.slice().sort((a,b)=>b-a);

  const C4_HZ = 261.625; // anchor

  let scale = [];
  let nameMap = null;
  let edoN = null;

  if (config.mode === 'edo'){
    edoN = config.edoN;
    if (!(edoN >= 2 && edoN <= 1200)) throw new Error("EDO divisions must be 2..1200");
    nameMap = buildEdoNameMap(edoN);
    scale = buildEdoScale(edoN, config.scaleLen, rng);
  } else {
    // JI scale pool
    const pool = new Set();
    while (pool.size < config.scaleLen){
      const r = randomJiRatio(config.jiPrimeLimit, config.jiSpan, rng);
      pool.add(toRatioString(...r));
    }
    scale = [...pool].map(s => s.split("/").map(Number));
  }

  // Build measures and durations
  const measures = [];
  for (let m=0; m<config.measures; m++){
    const durs = fillDurations(measureLen, allowed, rng);
    if (!durs) throw new Error("Could not pack durations; enable more durations.");
    measures.push(durs.map(d => ({ dur:d })));
  }

  // Assign melody via random walk
  for (let m=0; m<measures.length; m++){
    const cells = measures[m];
    const idxs = randomWalkIndices(cells.length, config.stepBias, rng);
    const lowOct = 0, hiOct = config.rangeOctaves - 1;
    for (let i=0;i<cells.length;i++){
      const deg = ((idxs[i] % scale.length) + scale.length) % scale.length;
      let oct = Math.floor(idxs[i] / scale.length);
      oct = clamp(oct, lowOct, hiOct);
      if (config.mode === 'edo'){
        const stepInOct = scale[deg]; // 0..N-1
        const absStep = oct*edoN + stepInOct; // relative to C4 as 0
        cells[i].mel = { stepAbs: absStep, stepInOct, octave: oct };
      } else {
        // normalize ratio to [1,2)
        let [n,d] = scale[deg];
        let v = n/d;
        while (v >= 2){ d*=2; v/=2; }
        while (v < 1){ n*=2; v*=2; }
        cells[i].mel = { ratio: reduceRatio(n,d), octave: oct };
      }
    }
  }

  // Harmony
  for (let m=0; m<measures.length; m++){
    const cells = measures[m];
    for (let i=0;i<cells.length;i++){
      if (Math.random() > config.chordDensity) continue; // density gating not seeded is fine
      if (config.mode === 'edo'){
        const chordSteps = edoChordForMelody(cells[i].mel.stepInOct, edoN, config.chordSize);
        cells[i].chord = chordSteps;
      } else {
        const ch = jiChordForMelody(cells[i].mel.ratio, config.chordSize);
        cells[i].chord = ch;
      }
    }
  }

  // Build text outputs
  let summary = "";
  if (config.mode === 'edo'){
    summary += `Mode: EDO/${edoN}\n`;
    summary += `Best fifth size (steps): ${nameMap.fifthSize}\n`;
    summary += `C4 = ${C4_HZ} Hz\n`;
    summary += `Scale steps: [ ${scale.map(s => nameMap.nameForStep[s]).join(", ")} ]\n`;
  } else {
    summary += `Mode: JI (prime-limit ≤ ${config.jiPrimeLimit})\n`;
    summary += `Max numerator/denominator: ${config.jiSpan}\n`;
    summary += `C4 = ${C4_HZ} Hz (as 1/1 reference for playback)\n`;
    summary += `Scale ratios: [ ${scale.map(r => toRatioString(...r)).join(", ")} ]\n`;
  }
  summary += `Meter: ${config.tsNum}/${config.tsDen}  •  Measures: ${config.measures}\n`;
  summary += `Durations: [ ${allowed.join(", ")} ] (whole=1)\n`;
  summary += `Chord size: ${config.chordSize}  •  Chord density: ${config.chordDensity}\n`;
  summary += `Tempo: ${config.bpm} BPM\n`;

  let measuresText = "";
  for (let m=0;m<measures.length;m++){
    measuresText += `Measure ${m+1}:\n`;
    for (const cell of measures[m]){
      if (config.mode === 'edo'){
        const melName = nameMap.nameForStep[cell.mel.stepInOct];
        measuresText += `  - Note: ${melName}  •  Dur: ${cell.dur}\n`;
        if (cell.chord){
          const chordNames = cell.chord.map(s => nameMap.nameForStep[s]);
          measuresText += `    Chord: [ ${chordNames.join(", ")} ]\n`;
        }
      } else {
        const melName = toRatioString(...cell.mel.ratio);
        measuresText += `  - Note: ${melName}  •  Dur: ${cell.dur}\n`;
        if (cell.chord){
          measuresText += `    Chord: [ ${cell.chord.map(r => toRatioString(...r)).join(", ")} ]\n`;
        }
      }
    }
    measuresText += "\n";
  }

  // Playback events
  const spb = 60 / config.bpm;
  const events = [];
  let tNow = 0;
  for (let m=0;m<measures.length;m++){
    for (const cell of measures[m]){
      const sec = cell.dur * 4 * spb; // whole=4 beats at quarter=1 beat
      if (config.mode === 'edo'){
        const abs = cell.mel.stepAbs;
        const hzMel = C4_HZ * Math.pow(2, abs / edoN) * Math.pow(2, config.transpose/12);
        events.push({ type:'mel', t:tNow, dur:sec, f:hzMel });
        if (cell.chord){
          for (const s of cell.chord){
            const delta = s - cell.mel.stepInOct;
            const absChord = abs + delta;
            const hzC = C4_HZ * Math.pow(2, absChord / edoN) * Math.pow(2, config.transpose/12);
            events.push({ type:'ch', t:tNow, dur:sec, f:hzC });
          }
        }
      } else {
        const base = C4_HZ * Math.pow(2, config.transpose/12);
        const r = cell.mel.ratio[0]/cell.mel.ratio[1];
        const hzMel = base * Math.pow(2, cell.mel.octave) * r;
        events.push({ type:'mel', t:tNow, dur:sec, f:hzMel });
        if (cell.chord){
          for (const rr of cell.chord){
            const hzC = base * Math.pow(2, cell.mel.octave) * (rr[0]/rr[1]);
            events.push({ type:'ch', t:tNow, dur:sec, f:hzC });
          }
        }
      }
      tNow += sec;
    }
  }

  return { summary, measuresText, events, nameMap, edoN, C4_HZ };
}

/* ======== Wire up UI ======== */
let AC = null, synth = null, playing = false, playTimer = null;

const el = id => document.getElementById(id);
const state = { data: null };

el('gen').addEventListener('click', () => {
  el('err').textContent = '';
  try {
    const config = {
      mode: el('mode').value,
      seed: Number(el('seed').value),
      edoN: Number(el('edoN').value),
      scaleLen: Number(el('scaleLen').value),
      jiPrimeLimit: Number(el('jiPrime').value),
      jiSpan: Number(el('jiSpan').value),
      tsNum: Number(el('tsNum').value),
      tsDen: Number(el('tsDen').value),
      measures: Number(el('measures').value),
      allowedDurations: Array.from(document.querySelectorAll('.dur'))
        .filter(x => x.checked).map(x => Number(x.value)).sort((a,b)=>b-a),
      rangeOctaves: Number(el('rangeOct').value),
      stepBias: Number(el('stepBias').value),
      chordDensity: Number(el('chordDensity').value),
      chordSize: Number(el('chordSize').value),
      bpm: Number(el('bpm').value),
      transpose: Number(el('transpose').value),
    };
    if (config.allowedDurations.length === 0) throw new Error("Select at least one duration.");
    const data = generate(config);
    state.data = data;
    el('summary').textContent = data.summary;
    el('measuresOut').textContent = data.measuresText;
    el('play').disabled = false;
    el('copy').disabled = false;
  } catch (e){
    el('err').textContent = String(e.message || e);
  }
});

el('play').addEventListener('click', async () => {
  if (!state.data || playing) return;
  if (!AC) { AC = new (window.AudioContext || window.webkitAudioContext)(); }
  if (!synth) synth = new Synth(AC);
  const startAt = AC.currentTime + 0.05;
  for (const ev of state.data.events){
    const t = startAt + ev.t;
    const dur = ev.dur * (ev.type === 'ch' ? 0.95 : 0.98);
    synth.note(ev.f, t, dur, ev.type === 'ch' ? 'triangle' : 'sine');
  }
  playing = true;
  const total = state.data.events.reduce((m,e)=>Math.max(m, e.t + e.dur), 0);
  el('stop').disabled = false;
  playTimer = setTimeout(()=>{ playing=false; el('stop').disabled = true; }, Math.ceil((total+0.2)*1000));
});

el('stop').addEventListener('click', () => {
  if (synth) synth.stopAll();
  if (playTimer) clearTimeout(playTimer);
  playing = false;
  el('stop').disabled = true;
});

el('copy').addEventListener('click', async () => {
  if (!state.data) return;
  const text = el('summary').textContent + "\n" + el('measuresOut').textContent;
  try { await navigator.clipboard.writeText(text); } catch(e){}
});
</script>
</body>
</html>
